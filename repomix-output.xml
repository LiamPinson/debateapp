This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: node_modules, dist, .next, .git, package-lock.json, yarn.lock, *.log, public, *.png, *.jpg, *.svg
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
app/
  api/
    auth/
      login/
        route.js
      oauth/
        route.js
      register/
        route.js
      session/
        route.js
    challenges/
      route.js
    daily/
      room/
        route.js
    debates/
      complete/
        route.js
      detail/
        route.js
      swap/
        route.js
    matchmaking/
      queue/
        route.js
    notifications/
      route.js
    og/
      profile/
        route.js
      route.js
    profile/
      me/
        route.js
    scoring/
      trigger/
        route.js
    topics/
      route.js
    votes/
      cast/
        route.js
  auth/
    callback/
      page.js
  components/
    AudioLevelBar.js
    DebateCard.js
    LoginModal.js
    MatchmakingModal.js
    Nav.js
    NotificationDropdown.js
    PhaseTimer.js
    RankBadge.js
    RegisterModal.js
    ScoreBar.js
    Toast.js
    TopicCard.js
    VoteBar.js
  debate/
    [id]/
      DebateClient.js
      page.js
  leaderboard/
    page.js
  profile/
    [id]/
      page.js
      ProfileClient.js
    page.js
  topics/
    page.js
    TopicsFilter.js
  globals.css
  HomeHero.js
  layout.js
  page.js
  providers.js
lib/
  queries/
    getDebateSSR.js
    getProfileSSR.js
  api-client.js
  daily.js
  deepgram.js
  matchmaking.js
  pipeline.js
  scoring.js
  SessionContext.js
  supabase.js
  useDaily.js
  useRealtime.js
supabase/
  schema.sql
.env.example
.gitignore
eslint.config.js
jsconfig.json
middleware.js
next.config.js
package.json
postcss.config.mjs
README.md
vercel.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/api/auth/login/route.js">
import { NextResponse } from "next/server";
import { createServiceClient } from "@/lib/supabase";
import { randomBytes, createHash } from "crypto";

/**
 * POST /api/auth/login
 * { email, password }
 * → signInWithPassword → look up user row → create session token → return { user, sessionToken }
 */
export async function POST(request) {
  try {
    const body = await request.json();
    const { email, password } = body;

    if (!email || !password) {
      return NextResponse.json({ error: "email and password required" }, { status: 400 });
    }

    const db = createServiceClient();

    const { data: authData, error: authError } = await db.auth.signInWithPassword({ email, password });

    if (authError) {
      return NextResponse.json({ error: "Invalid email or password." }, { status: 401 });
    }

    // Look up user record
    const { data: user, error: userError } = await db
      .from("users")
      .select("id, username, email, rank_tier, quality_score_avg, wins, losses, draws, total_debates")
      .eq("email", email)
      .single();

    if (userError || !user) {
      return NextResponse.json({ error: "Account not found." }, { status: 404 });
    }

    // Generate a session token so the client can persist the login
    const sessionToken = randomBytes(32).toString("hex");
    const tokenHash = createHash("sha256").update(sessionToken).digest("hex");

    await db.from("sessions").insert({ token_hash: tokenHash });

    return NextResponse.json({
      user: {
        id: user.id,
        username: user.username,
        quality_score: user.quality_score_avg,
        rank_tier: user.rank_tier,
        total_debates: user.total_debates,
        wins: user.wins,
        losses: user.losses,
        draws: user.draws,
      },
      sessionToken,
    });
  } catch (err) {
    console.error("Login route error:", err);
    return NextResponse.json({ error: err.message }, { status: 500 });
  }
}
</file>

<file path="app/api/auth/oauth/route.js">
import { NextResponse } from "next/server";
import { createServiceClient } from "@/lib/supabase";
import { randomBytes, createHash } from "crypto";

/**
 * POST /api/auth/oauth
 * { accessToken }
 * Verifies a Supabase OAuth access token, finds or creates a user row,
 * creates a session token, and returns { user, sessionToken }.
 */
export async function POST(request) {
  try {
    const { accessToken } = await request.json();

    if (!accessToken) {
      return NextResponse.json({ error: "accessToken required" }, { status: 400 });
    }

    const db = createServiceClient();

    // Verify the access token with Supabase
    const { data: { user: supabaseUser }, error: authError } = await db.auth.getUser(accessToken);

    if (authError || !supabaseUser) {
      return NextResponse.json({ error: "Invalid access token" }, { status: 401 });
    }

    // Look up existing user row by auth_id
    const { data: existingUser } = await db
      .from("users")
      .select("id, username, email, rank_tier, quality_score_avg, wins, losses, draws, total_debates")
      .eq("auth_id", supabaseUser.id)
      .single();

    let user = existingUser;

    if (!user) {
      // First Google login — auto-generate username from full name or email prefix
      const fullName = supabaseUser.user_metadata?.full_name || "";
      const emailPrefix = supabaseUser.email?.split("@")[0] || "user";
      let base = (fullName || emailPrefix)
        .replace(/[^a-zA-Z0-9_]/g, "")
        .slice(0, 24);
      if (base.length < 3) base = base.padEnd(3, "0");

      // Check if username is taken
      const { data: taken } = await db
        .from("users")
        .select("id")
        .eq("username", base)
        .limit(1);

      let username = base;
      if (taken && taken.length > 0) {
        const suffix = Math.floor(1000 + Math.random() * 9000);
        username = base.slice(0, 20) + suffix;
      }

      const { data: newUser, error: insertError } = await db
        .from("users")
        .insert({
          auth_id: supabaseUser.id,
          username,
          email: supabaseUser.email,
          quality_score_avg: 50,
          rank_tier: "Bronze",
        })
        .select("id, username, email, rank_tier, quality_score_avg, wins, losses, draws, total_debates")
        .single();

      if (insertError) {
        console.error("User creation failed:", insertError);
        return NextResponse.json({ error: insertError.message }, { status: 500 });
      }

      user = newUser;
    }

    // Generate session token
    const sessionToken = randomBytes(32).toString("hex");
    const tokenHash = createHash("sha256").update(sessionToken).digest("hex");

    await db.from("sessions").insert({ token_hash: tokenHash });

    return NextResponse.json({
      user: {
        id: user.id,
        username: user.username,
        quality_score: user.quality_score_avg,
        rank_tier: user.rank_tier,
        total_debates: user.total_debates,
        wins: user.wins,
        losses: user.losses,
        draws: user.draws,
      },
      sessionToken,
    });
  } catch (err) {
    console.error("OAuth route error:", err);
    return NextResponse.json({ error: err.message }, { status: 500 });
  }
}
</file>

<file path="app/api/challenges/route.js">
import { NextResponse } from "next/server";
import { createServiceClient } from "@/lib/supabase";

/**
 * POST /api/challenges
 * Create a new challenge.
 *
 * Body: { challengerId, targetId, topicId, timeLimit? }
 */
export async function POST(request) {
  try {
    const body = await request.json();
    const { challengerId, targetId, topicId, timeLimit } = body;

    if (!challengerId || !targetId || !topicId) {
      return NextResponse.json(
        { error: "challengerId, targetId, and topicId are required" },
        { status: 400 }
      );
    }

    if (challengerId === targetId) {
      return NextResponse.json({ error: "Cannot challenge yourself" }, { status: 400 });
    }

    const db = createServiceClient();

    // Check for existing pending challenge between these users
    const { data: existing } = await db
      .from("challenges")
      .select("id")
      .eq("challenger_id", challengerId)
      .eq("target_id", targetId)
      .eq("status", "pending")
      .limit(1);

    if (existing && existing.length > 0) {
      return NextResponse.json(
        { error: "You already have a pending challenge to this user" },
        { status: 409 }
      );
    }

    const { data: challenge, error } = await db
      .from("challenges")
      .insert({
        challenger_id: challengerId,
        target_id: targetId,
        topic_id: topicId,
        time_limit: timeLimit || 15,
        status: "pending",
      })
      .select()
      .single();

    if (error) return NextResponse.json({ error: error.message }, { status: 500 });

    // Notify the target
    await db.from("notifications").insert({
      user_id: targetId,
      type: "challenge_received",
      title: "New challenge!",
      body: "Someone has challenged you to a debate.",
      data: { challenge_id: challenge.id, challenger_id: challengerId, topic_id: topicId },
    });

    return NextResponse.json({ challenge });
  } catch (err) {
    return NextResponse.json({ error: err.message }, { status: 500 });
  }
}

/**
 * PATCH /api/challenges
 * Accept or decline a challenge.
 *
 * Body: { challengeId, action: 'accept' | 'decline' }
 */
export async function PATCH(request) {
  try {
    const body = await request.json();
    const { challengeId, action } = body;

    if (!challengeId || !["accept", "decline"].includes(action)) {
      return NextResponse.json(
        { error: "challengeId and action (accept/decline) required" },
        { status: 400 }
      );
    }

    const db = createServiceClient();

    const { data: challenge } = await db
      .from("challenges")
      .select("*")
      .eq("id", challengeId)
      .eq("status", "pending")
      .single();

    if (!challenge) {
      return NextResponse.json({ error: "Challenge not found or already resolved" }, { status: 404 });
    }

    const newStatus = action === "accept" ? "accepted" : "declined";

    const { error } = await db
      .from("challenges")
      .update({ status: newStatus })
      .eq("id", challengeId);

    if (error) return NextResponse.json({ error: error.message }, { status: 500 });

    // Notify the challenger
    await db.from("notifications").insert({
      user_id: challenge.challenger_id,
      type: "challenge_received",
      title: `Challenge ${newStatus}!`,
      body: action === "accept"
        ? "Your challenge was accepted. Get ready to debate!"
        : "Your challenge was declined.",
      data: { challenge_id: challengeId },
    });

    return NextResponse.json({ success: true, status: newStatus });
  } catch (err) {
    return NextResponse.json({ error: err.message }, { status: 500 });
  }
}

/**
 * GET /api/challenges?userId=<uuid>&type=received|sent
 * List challenges for a user.
 */
export async function GET(request) {
  try {
    const { searchParams } = new URL(request.url);
    const userId = searchParams.get("userId");
    const type = searchParams.get("type") || "received";

    if (!userId) {
      return NextResponse.json({ error: "userId required" }, { status: 400 });
    }

    const db = createServiceClient();

    const column = type === "sent" ? "challenger_id" : "target_id";
    const { data, error } = await db
      .from("challenges")
      .select("*, topics(title, short_title, category)")
      .eq(column, userId)
      .order("created_at", { ascending: false })
      .limit(20);

    if (error) return NextResponse.json({ error: error.message }, { status: 500 });
    return NextResponse.json({ challenges: data });
  } catch (err) {
    return NextResponse.json({ error: err.message }, { status: 500 });
  }
}
</file>

<file path="app/api/daily/room/route.js">
import { NextResponse } from "next/server";
import { createDailyRoom, createMeetingToken } from "@/lib/daily";
import { createServiceClient } from "@/lib/supabase";

/**
 * POST /api/daily/room
 * Get or create a Daily.co room for a debate, and generate a participant token.
 *
 * Body: { debateId, userId?, sessionId?, side }
 */
export async function POST(request) {
  try {
    const body = await request.json();
    const { debateId, userId, sessionId, side } = body;

    if (!debateId || !side) {
      return NextResponse.json({ error: "debateId and side are required" }, { status: 400 });
    }

    const db = createServiceClient();

    // Get debate record
    const { data: debate, error } = await db
      .from("debates")
      .select("*")
      .eq("id", debateId)
      .single();

    if (error || !debate) {
      return NextResponse.json({ error: "Debate not found" }, { status: 404 });
    }

    // Verify this user is a participant
    const isProUser = (userId && debate.pro_user_id === userId) || (sessionId && debate.pro_session_id === sessionId);
    const isConUser = (userId && debate.con_user_id === userId) || (sessionId && debate.con_session_id === sessionId);

    if (!isProUser && !isConUser) {
      return NextResponse.json({ error: "Not a participant in this debate" }, { status: 403 });
    }

    // Room should already exist (created during matchmaking)
    if (!debate.daily_room_name) {
      return NextResponse.json({ error: "No room assigned to this debate" }, { status: 400 });
    }

    // Generate meeting token
    const label = userId
      ? (await db.from("users").select("username").eq("id", userId).single()).data?.username || side
      : side.charAt(0).toUpperCase() + side.slice(1);

    const isOwner = side === "pro"; // Pro controls recording
    const token = await createMeetingToken(debate.daily_room_name, label, isOwner);

    return NextResponse.json({
      room_name: debate.daily_room_name,
      room_url: debate.daily_room_url,
      token,
      domain: process.env.NEXT_PUBLIC_DAILY_DOMAIN,
    });
  } catch (err) {
    console.error("Daily room error:", err);
    return NextResponse.json({ error: err.message }, { status: 500 });
  }
}
</file>

<file path="app/api/debates/swap/route.js">
import { NextResponse } from "next/server";
import { requestSideSwap } from "@/lib/matchmaking";

/**
 * POST /api/debates/swap
 * Request a side swap during prematch lobby.
 *
 * Body: { debateId, requestingSide }
 */
export async function POST(request) {
  try {
    const body = await request.json();
    const { debateId, requestingSide } = body;

    if (!debateId || !requestingSide) {
      return NextResponse.json(
        { error: "debateId and requestingSide required" },
        { status: 400 }
      );
    }

    if (!["pro", "con"].includes(requestingSide)) {
      return NextResponse.json({ error: "requestingSide must be 'pro' or 'con'" }, { status: 400 });
    }

    const result = await requestSideSwap(debateId, requestingSide);
    return NextResponse.json(result);
  } catch (err) {
    return NextResponse.json({ error: err.message }, { status: 500 });
  }
}
</file>

<file path="app/api/notifications/route.js">
import { NextResponse } from "next/server";
import { createServiceClient } from "@/lib/supabase";

/**
 * GET /api/notifications?userId=<uuid>&unreadOnly=true&limit=50
 * List notifications for a user.
 */
export async function GET(request) {
  try {
    const { searchParams } = new URL(request.url);
    const userId = searchParams.get("userId");
    const unreadOnly = searchParams.get("unreadOnly") === "true";
    const limit = Math.min(parseInt(searchParams.get("limit") || "50"), 100);

    if (!userId) {
      return NextResponse.json({ error: "userId required" }, { status: 400 });
    }

    const db = createServiceClient();
    let query = db
      .from("notifications")
      .select("*")
      .eq("user_id", userId)
      .order("created_at", { ascending: false })
      .limit(limit);

    if (unreadOnly) {
      query = query.eq("read", false);
    }

    const { data, error } = await query;

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    return NextResponse.json({ notifications: data });
  } catch (err) {
    return NextResponse.json({ error: err.message }, { status: 500 });
  }
}

/**
 * PATCH /api/notifications
 * Mark notifications as read.
 *
 * Body: { notificationIds: string[] } or { userId: string, markAllRead: true }
 */
export async function PATCH(request) {
  try {
    const body = await request.json();
    const { notificationIds, userId, markAllRead } = body;
    const db = createServiceClient();

    if (markAllRead && userId) {
      const { error } = await db
        .from("notifications")
        .update({ read: true })
        .eq("user_id", userId)
        .eq("read", false);

      if (error) return NextResponse.json({ error: error.message }, { status: 500 });
      return NextResponse.json({ success: true });
    }

    if (!notificationIds || notificationIds.length === 0) {
      return NextResponse.json({ error: "notificationIds or markAllRead required" }, { status: 400 });
    }

    const { error } = await db
      .from("notifications")
      .update({ read: true })
      .in("id", notificationIds);

    if (error) return NextResponse.json({ error: error.message }, { status: 500 });
    return NextResponse.json({ success: true });
  } catch (err) {
    return NextResponse.json({ error: err.message }, { status: 500 });
  }
}
</file>

<file path="app/api/topics/route.js">
import { NextResponse } from 'next/server';
import { createServiceClient } from '@/lib/supabase';

export async function GET() {
  const db = createServiceClient();
  const { data: topics, error } = await db
    .from('topics')
    .select('*')
    .eq('active', true)
    .order('category')
    .order('title');
  if (error) return NextResponse.json({ error: error.message }, { status: 500 });
  return NextResponse.json({ topics });
}
</file>

<file path="app/api/votes/cast/route.js">
import { NextResponse } from "next/server";
import { createServiceClient } from "@/lib/supabase";

/**
 * POST /api/votes/cast
 * Cast a vote on a debate. One vote per user, unweighted.
 *
 * Body: { debateId, voterId, winnerChoice, betterArguments?, moreRespectful?, changedMind? }
 */
export async function POST(request) {
  try {
    const body = await request.json();
    const { debateId, voterId, winnerChoice, betterArguments, moreRespectful, changedMind } = body;

    if (!debateId || !voterId || !winnerChoice) {
      return NextResponse.json(
        { error: "debateId, voterId, and winnerChoice required" },
        { status: 400 }
      );
    }

    if (!["pro", "con", "draw"].includes(winnerChoice)) {
      return NextResponse.json({ error: "winnerChoice must be pro, con, or draw" }, { status: 400 });
    }

    const db = createServiceClient();

    // Verify debate exists and is completed
    const { data: debate } = await db
      .from("debates")
      .select("id, status, pro_user_id, con_user_id")
      .eq("id", debateId)
      .single();

    if (!debate || debate.status !== "completed") {
      return NextResponse.json({ error: "Debate not found or not completed" }, { status: 404 });
    }

    // Can't vote on own debate
    if (debate.pro_user_id === voterId || debate.con_user_id === voterId) {
      return NextResponse.json({ error: "Cannot vote on your own debate" }, { status: 403 });
    }

    // Upsert vote (replaces if already voted)
    const { data: vote, error } = await db
      .from("votes")
      .upsert(
        {
          debate_id: debateId,
          voter_id: voterId,
          winner_choice: winnerChoice,
          better_arguments: betterArguments || null,
          more_respectful: moreRespectful || null,
          changed_mind: changedMind ?? null,
        },
        { onConflict: "debate_id,voter_id" }
      )
      .select()
      .single();

    if (error) {
      console.error("Vote error:", error);
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    // Recalculate vote tally
    const { data: tally } = await db
      .from("votes")
      .select("winner_choice")
      .eq("debate_id", debateId);

    const counts = { pro: 0, con: 0, draw: 0 };
    (tally || []).forEach((v) => counts[v.winner_choice]++);
    const total = counts.pro + counts.con + counts.draw;

    // Determine winner by simple majority
    let winner = "draw";
    if (total > 0) {
      const proPercent = counts.pro / total;
      const conPercent = counts.con / total;
      if (Math.abs(proPercent - conPercent) > 0.05) {
        winner = proPercent > conPercent ? "pro" : "con";
      }
    }

    // Update debate with community vote result
    await db
      .from("debates")
      .update({ winner, winner_source: "community" })
      .eq("id", debateId)
      .eq("status", "completed");

    // Update W/L records for participants
    await updateWinLoss(db, debate, winner);

    return NextResponse.json({
      success: true,
      vote,
      tally: counts,
      total,
      winner,
    });
  } catch (err) {
    console.error("Vote error:", err);
    return NextResponse.json({ error: err.message }, { status: 500 });
  }
}

/**
 * GET /api/votes/cast?debateId=xxx
 * Get vote tally for a debate.
 */
export async function GET(request) {
  try {
    const { searchParams } = new URL(request.url);
    const debateId = searchParams.get("debateId");

    if (!debateId) {
      return NextResponse.json({ error: "debateId required" }, { status: 400 });
    }

    const db = createServiceClient();

    const { data: tally } = await db
      .from("votes")
      .select("winner_choice")
      .eq("debate_id", debateId);

    const counts = { pro: 0, con: 0, draw: 0 };
    (tally || []).forEach((v) => counts[v.winner_choice]++);

    return NextResponse.json({ tally: counts, total: counts.pro + counts.con + counts.draw });
  } catch (err) {
    return NextResponse.json({ error: err.message }, { status: 500 });
  }
}

async function updateWinLoss(db, debate, winner) {
  if (winner === "draw") {
    // Both get draws
    for (const uid of [debate.pro_user_id, debate.con_user_id]) {
      if (!uid) continue;
      const { data } = await db.from("users").select("draws").eq("id", uid).single();
      if (data) await db.from("users").update({ draws: data.draws + 1 }).eq("id", uid);
    }
  } else {
    const winnerId = winner === "pro" ? debate.pro_user_id : debate.con_user_id;
    const loserId = winner === "pro" ? debate.con_user_id : debate.pro_user_id;

    if (winnerId) {
      const { data } = await db.from("users").select("wins").eq("id", winnerId).single();
      if (data) await db.from("users").update({ wins: data.wins + 1 }).eq("id", winnerId);
    }
    if (loserId) {
      const { data } = await db.from("users").select("losses").eq("id", loserId).single();
      if (data) await db.from("users").update({ losses: data.losses + 1 }).eq("id", loserId);
    }
  }
}
</file>

<file path="app/auth/callback/page.js">
"use client";

import { useEffect, useState } from "react";
import { useRouter } from "next/navigation";
import { createBrowserClient } from "@/lib/supabase";
import { loginWithOAuth } from "@/lib/api-client";
import { useSession } from "@/lib/SessionContext";

const SESSION_KEY = "debate_session_token";

export default function AuthCallbackPage() {
  const router = useRouter();
  const { login } = useSession();
  const [error, setError] = useState(null);

  useEffect(() => {
    async function handleCallback() {
      try {
        const code = new URLSearchParams(window.location.search).get("code");
        if (!code) {
          setError("No authorization code found.");
          return;
        }

        const supabase = createBrowserClient();
        const { data, error: exchangeError } = await supabase.auth.exchangeCodeForSession(code);

        if (exchangeError || !data?.session) {
          setError(exchangeError?.message || "Failed to exchange code for session.");
          return;
        }

        const result = await loginWithOAuth(data.session.access_token);

        if (result.error) {
          setError(result.error);
          return;
        }

        localStorage.setItem(SESSION_KEY, result.sessionToken);
        login(result.user);
        router.push("/");
      } catch (err) {
        setError(err.message);
      }
    }

    handleCallback();
  }, []);

  if (error) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-arena-bg">
        <div className="text-center">
          <p className="text-arena-con mb-4">{error}</p>
          <a href="/" className="text-arena-accent hover:underline text-sm">
            Return home
          </a>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-arena-bg">
      <div className="text-center text-arena-muted text-sm">Signing you in...</div>
    </div>
  );
}
</file>

<file path="app/components/AudioLevelBar.js">
"use client";

export default function AudioLevelBar({ level = 0, side = "pro" }) {
  const color = side === "pro" ? "bg-arena-pro" : "bg-arena-con";

  return (
    <div className="flex items-end gap-0.5 h-6">
      {[0.15, 0.3, 0.45, 0.6, 0.8].map((threshold, i) => (
        <div
          key={i}
          className={`w-1 rounded-full transition-all duration-100 ${
            level >= threshold ? color : "bg-arena-border"
          }`}
          style={{ height: `${40 + i * 15}%` }}
        />
      ))}
    </div>
  );
}
</file>

<file path="app/components/LoginModal.js">
"use client";

import { useState } from "react";
import { useSession } from "@/lib/SessionContext";
import { loginWithPassword } from "@/lib/api-client";
import { createBrowserClient } from "@/lib/supabase";

const SESSION_KEY = "debate_session_token";

function GoogleIcon() {
  return (
    <svg width="18" height="18" viewBox="0 0 18 18" xmlns="http://www.w3.org/2000/svg">
      <path d="M17.64 9.2c0-.637-.057-1.251-.164-1.84H9v3.481h4.844a4.14 4.14 0 0 1-1.796 2.716v2.259h2.908c1.702-1.567 2.684-3.875 2.684-6.615z" fill="#4285F4"/>
      <path d="M9 18c2.43 0 4.467-.806 5.956-2.18l-2.908-2.259c-.806.54-1.837.86-3.048.86-2.344 0-4.328-1.584-5.036-3.711H.957v2.332A8.997 8.997 0 0 0 9 18z" fill="#34A853"/>
      <path d="M3.964 10.71A5.41 5.41 0 0 1 3.682 9c0-.593.102-1.17.282-1.71V4.958H.957A8.996 8.996 0 0 0 0 9c0 1.452.348 2.827.957 4.042l3.007-2.332z" fill="#FBBC05"/>
      <path d="M9 3.58c1.321 0 2.508.454 3.44 1.345l2.582-2.58C13.463.891 11.426 0 9 0A8.997 8.997 0 0 0 .957 4.958L3.964 7.29C4.672 5.163 6.656 3.58 9 3.58z" fill="#EA4335"/>
    </svg>
  );
}

export default function LoginModal({ open, onClose }) {
  const { login } = useSession();
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState(null);
  const [loading, setLoading] = useState(false);

  if (!open) return null;

  const handleClose = () => {
    setEmail("");
    setPassword("");
    setError(null);
    onClose();
  };

  const handleGoogle = async () => {
    setError(null);
    const supabase = createBrowserClient();
    const { error: oauthError } = await supabase.auth.signInWithOAuth({
      provider: "google",
      options: { redirectTo: window.location.origin + "/auth/callback" },
    });
    if (oauthError) setError(oauthError.message);
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError(null);
    setLoading(true);
    try {
      const result = await loginWithPassword(email, password);
      if (result.error) {
        setError(result.error);
      } else {
        if (result.sessionToken) {
          localStorage.setItem(SESSION_KEY, result.sessionToken);
        }
        login(result.user);
        handleClose();
      }
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm">
      <div className="bg-arena-surface border border-arena-border rounded-xl p-6 w-full max-w-md mx-4">
        <h2 className="text-xl font-bold mb-2">Sign In</h2>
        <p className="text-sm text-arena-muted mb-4">Enter your email and password to sign in.</p>

        <div className="space-y-4">
          <button
            onClick={handleGoogle}
            className="w-full flex items-center justify-center gap-3 px-4 py-2 border border-arena-border rounded-lg text-sm hover:bg-arena-border/30 transition-colors"
          >
            <GoogleIcon /> Continue with Google
          </button>

          <div className="flex items-center gap-3 text-arena-muted text-xs">
            <hr className="flex-1 border-arena-border" />
            or
            <hr className="flex-1 border-arena-border" />
          </div>

          <form onSubmit={handleSubmit} className="space-y-4">
            <div>
              <label className="block text-sm font-medium mb-1">Email</label>
              <input
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                required
                autoFocus
                className="w-full bg-arena-bg border border-arena-border rounded-lg px-3 py-2 text-sm focus:outline-none focus:border-arena-accent"
                placeholder="you@example.com"
              />
            </div>

            <div>
              <label className="block text-sm font-medium mb-1">Password</label>
              <input
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                required
                className="w-full bg-arena-bg border border-arena-border rounded-lg px-3 py-2 text-sm focus:outline-none focus:border-arena-accent"
                placeholder="••••••••"
              />
            </div>

            {error && <p className="text-sm text-arena-con">{error}</p>}

            <div className="flex gap-3">
              <button
                type="button"
                onClick={handleClose}
                className="flex-1 px-4 py-2 border border-arena-border rounded-lg text-sm hover:bg-arena-border/30 transition-colors"
              >
                Cancel
              </button>
              <button
                type="submit"
                disabled={loading}
                className="flex-1 px-4 py-2 bg-arena-accent text-white rounded-lg text-sm font-medium hover:bg-arena-accent/80 transition-colors disabled:opacity-50"
              >
                {loading ? "Signing in..." : "Sign In"}
              </button>
            </div>
          </form>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/components/NotificationDropdown.js">
"use client";

import { useState, useEffect, useRef } from "react";
import { useSession } from "@/lib/SessionContext";
import { useRealtimeNotifications } from "@/lib/useRealtime";
import { getNotifications, markAllNotificationsRead } from "@/lib/api-client";

export default function NotificationDropdown() {
  const { user } = useSession();
  const [open, setOpen] = useState(false);
  const [notifications, setNotifications] = useState([]);
  const [unreadCount, setUnreadCount] = useState(0);
  const ref = useRef(null);

  // Load notifications
  useEffect(() => {
    if (!user?.id) return;
    getNotifications(user.id, { limit: 20 }).then((data) => {
      if (data.notifications) {
        setNotifications(data.notifications);
        setUnreadCount(data.notifications.filter((n) => !n.read).length);
      }
    });
  }, [user?.id]);

  // Realtime updates
  useRealtimeNotifications(user?.id, (newNotif) => {
    setNotifications((prev) => [newNotif, ...prev].slice(0, 20));
    setUnreadCount((c) => c + 1);
  });

  // Close on click outside
  useEffect(() => {
    const handler = (e) => {
      if (ref.current && !ref.current.contains(e.target)) setOpen(false);
    };
    document.addEventListener("mousedown", handler);
    return () => document.removeEventListener("mousedown", handler);
  }, []);

  const handleMarkAllRead = async () => {
    if (!user?.id) return;
    await markAllNotificationsRead(user.id);
    setNotifications((n) => n.map((x) => ({ ...x, read: true })));
    setUnreadCount(0);
  };

  return (
    <div ref={ref} className="relative">
      <button
        onClick={() => setOpen(!open)}
        className="relative p-2 text-arena-muted hover:text-arena-text transition-colors"
      >
        <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
          <path strokeLinecap="round" strokeLinejoin="round" d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9" />
        </svg>
        {unreadCount > 0 && (
          <span className="absolute -top-0.5 -right-0.5 w-4 h-4 bg-arena-con text-white text-xs flex items-center justify-center rounded-full">
            {unreadCount > 9 ? "9+" : unreadCount}
          </span>
        )}
      </button>

      {open && (
        <div className="absolute right-0 mt-2 w-80 bg-arena-surface border border-arena-border rounded-lg shadow-xl z-50 max-h-96 overflow-hidden">
          <div className="flex items-center justify-between px-4 py-3 border-b border-arena-border">
            <span className="font-semibold text-sm">Notifications</span>
            {unreadCount > 0 && (
              <button onClick={handleMarkAllRead} className="text-xs text-arena-accent hover:underline">
                Mark all read
              </button>
            )}
          </div>
          <div className="overflow-y-auto max-h-80">
            {notifications.length === 0 ? (
              <p className="text-sm text-arena-muted text-center py-8">No notifications</p>
            ) : (
              notifications.map((n) => (
                <div
                  key={n.id}
                  className={`px-4 py-3 border-b border-arena-border/50 text-sm ${
                    n.read ? "opacity-60" : ""
                  }`}
                >
                  <p className="font-medium text-xs">{n.title}</p>
                  {n.body && <p className="text-arena-muted text-xs mt-0.5">{n.body}</p>}
                </div>
              ))
            )}
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="app/components/ScoreBar.js">
"use client";

export default function ScoreBar({ label, score = 0, maxScore = 100, color = "accent" }) {
  const pct = Math.min(100, Math.max(0, (score / maxScore) * 100));
  const colorClass = color === "pro" ? "bg-arena-pro" : color === "con" ? "bg-arena-con" : "bg-arena-accent";

  return (
    <div>
      <div className="flex justify-between text-sm mb-1">
        <span className="text-arena-muted">{label}</span>
        <span className="font-mono font-medium">{score.toFixed(1)}</span>
      </div>
      <div className="h-2 bg-arena-border rounded-full overflow-hidden">
        <div
          className={`h-full rounded-full transition-all duration-500 ${colorClass}`}
          style={{ width: `${pct}%` }}
        />
      </div>
    </div>
  );
}
</file>

<file path="app/components/Toast.js">
"use client";

import { useState, useEffect, createContext, useContext, useCallback } from "react";

const ToastContext = createContext(null);

export function ToastProvider({ children }) {
  const [toasts, setToasts] = useState([]);

  const addToast = useCallback((message, type = "info", duration = 4000) => {
    const id = Date.now();
    setToasts((t) => [...t, { id, message, type }]);
    setTimeout(() => {
      setToasts((t) => t.filter((toast) => toast.id !== id));
    }, duration);
  }, []);

  return (
    <ToastContext.Provider value={addToast}>
      {children}
      <div className="fixed bottom-4 right-4 z-50 flex flex-col gap-2">
        {toasts.map((toast) => (
          <div
            key={toast.id}
            className={`px-4 py-3 rounded-lg text-sm font-medium shadow-lg animate-slide-up ${
              toast.type === "success" ? "bg-emerald-900 text-emerald-200 border border-emerald-700" :
              toast.type === "error" ? "bg-red-900 text-red-200 border border-red-700" :
              "bg-arena-surface text-arena-text border border-arena-border"
            }`}
          >
            {toast.message}
          </div>
        ))}
      </div>
    </ToastContext.Provider>
  );
}

export function useToast() {
  const ctx = useContext(ToastContext);
  if (!ctx) throw new Error("useToast must be used within ToastProvider");
  return ctx;
}
</file>

<file path="app/components/VoteBar.js">
"use client";

export default function VoteBar({ pro = 0, con = 0, draw = 0 }) {
  const total = pro + con + draw || 1;
  const proP = Math.round((pro / total) * 100);
  const conP = Math.round((con / total) * 100);
  const drawP = 100 - proP - conP;

  return (
    <div>
      <div className="flex h-4 rounded-full overflow-hidden bg-arena-border">
        {proP > 0 && (
          <div className="bg-arena-pro transition-all" style={{ width: `${proP}%` }} />
        )}
        {drawP > 0 && (
          <div className="bg-arena-muted/40 transition-all" style={{ width: `${drawP}%` }} />
        )}
        {conP > 0 && (
          <div className="bg-arena-con transition-all" style={{ width: `${conP}%` }} />
        )}
      </div>
      <div className="flex justify-between text-xs text-arena-muted mt-1">
        <span className="text-arena-pro">Pro {proP}%</span>
        <span>Draw {drawP}%</span>
        <span className="text-arena-con">Con {conP}%</span>
      </div>
    </div>
  );
}
</file>

<file path="app/debate/[id]/DebateClient.js">
"use client";

import { useState, useEffect, useCallback } from "react";
import { useRouter } from "next/navigation";
import { useSession } from "@/lib/SessionContext";
import { useRealtimeDebate } from "@/lib/useRealtime";
import { useDaily } from "@/lib/useDaily";
import {
  getDebateDetail,
  getDailyToken,
  requestSideSwap,
  startDebate,
  advancePhase,
  completeDebate,
  forfeitDebate,
  castVote,
  getVoteTally,
} from "@/lib/api-client";
import PhaseTimer, { getPhaseDuration } from "../../components/PhaseTimer";
import AudioLevelBar from "../../components/AudioLevelBar";
import RankBadge from "../../components/RankBadge";
import ScoreBar from "../../components/ScoreBar";
import VoteBar from "../../components/VoteBar";

const PHASE_ORDER = ["prematch", "opening_pro", "opening_con", "freeflow", "closing_con", "closing_pro", "ended"];

export default function DebateClient({ initialDebate, params }) {
  const { id: debateId } = params;
  const router = useRouter();
  const { user, session } = useSession();
  const [debate, setDebate] = useState(initialDebate || null);
  const [loading, setLoading] = useState(!initialDebate);
  const [dailyToken, setDailyToken] = useState(null);
  const [forfeitConfirm, setForfeitConfirm] = useState(false);
  const [votes, setVotes] = useState(null);
  const [voted, setVoted] = useState(false);

  // Determine which side the current user is on
  const mySide =
    debate?.pro_user_id === user?.id || debate?.pro_session_id === session?.id
      ? "pro"
      : debate?.con_user_id === user?.id || debate?.con_session_id === session?.id
      ? "con"
      : null;

  // Load debate detail — skipped if initialDebate was provided by the server
  useEffect(() => {
    if (initialDebate) return;
    getDebateDetail(debateId).then((data) => {
      setDebate(data.debate || data);
      setLoading(false);
    });
  }, [debateId, initialDebate]);

  // Realtime debate updates
  const onDebateChange = useCallback((updated) => {
    setDebate((prev) => ({ ...prev, ...updated }));
  }, []);
  useRealtimeDebate(debateId, onDebateChange);

  // Get Daily.co token when debate is in_progress
  useEffect(() => {
    if (!debate || debate.status !== "in_progress" || dailyToken) return;
    if (!mySide) return;
    getDailyToken(debateId, user?.id, session?.id, mySide).then((data) => {
      setDailyToken(data);
    });
  }, [debate?.status, debateId, user?.id, session?.id, mySide, dailyToken]);

  // Daily.co audio
  const daily = useDaily({
    roomUrl: dailyToken?.roomUrl || dailyToken?.room_url || "",
    token: dailyToken?.token || "",
    autoJoin: !!dailyToken?.token,
  });

  // Load votes for completed debates
  useEffect(() => {
    if (debate?.status === "completed") {
      getVoteTally(debateId).then((data) => setVotes(data));
    }
  }, [debate?.status, debateId]);

  // Phase advance handler
  const handleTimeUp = useCallback(async () => {
    if (!debate || !mySide) return;
    const currentIdx = PHASE_ORDER.indexOf(debate.phase);
    const nextPhase = PHASE_ORDER[currentIdx + 1];
    if (nextPhase === "ended") {
      await completeDebate(debateId);
    } else if (nextPhase) {
      await advancePhase(debateId, nextPhase);
    }
  }, [debate, debateId, mySide]);

  // Forfeit handler
  const handleForfeit = async () => {
    if (!mySide) return;
    await forfeitDebate(debateId, mySide);
    setForfeitConfirm(false);
  };

  // Vote handler
  const handleVote = async (choice) => {
    if (!user?.id || voted) return;
    await castVote(debateId, user.id, choice);
    setVoted(true);
    getVoteTally(debateId).then((data) => setVotes(data));
  };

  // Ready / Start
  const handleStart = async () => {
    await startDebate(debateId);
  };

  // Side swap
  const handleSwap = async () => {
    if (!mySide) return;
    await requestSideSwap(debateId, mySide);
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-[60vh]">
        <div className="w-10 h-10 border-4 border-arena-accent border-t-transparent rounded-full animate-spin" />
      </div>
    );
  }

  if (!debate) {
    return (
      <div className="text-center py-20">
        <p className="text-arena-muted">Debate not found.</p>
      </div>
    );
  }

  // ─── PREMATCH ────────────────────────────────────────
  if (debate.status === "prematch") {
    return (
      <div className="max-w-2xl mx-auto px-4 py-12">
        <div className="bg-arena-surface border border-arena-border rounded-xl p-8 text-center">
          <p className="text-sm text-arena-muted mb-2">Prematch Lobby</p>
          <h2 className="text-2xl font-bold mb-6">{debate.topic_title || "Quick Match"}</h2>
          {debate.topic_description && (
            <p className="text-sm text-arena-muted mb-6">{debate.topic_description}</p>
          )}

          <div className="flex items-center justify-center gap-8 mb-8">
            {/* Pro side */}
            <div className={`text-center ${mySide === "pro" ? "ring-2 ring-arena-pro rounded-xl p-4" : "p-4"}`}>
              <div className="w-16 h-16 bg-arena-pro/20 rounded-full flex items-center justify-center mx-auto mb-2">
                <span className="text-2xl font-bold text-arena-pro">P</span>
              </div>
              <p className="font-semibold text-arena-pro">Pro</p>
              <p className="text-sm">{debate.pro_username || "Guest"}</p>
              {debate.pro_rank_tier && <RankBadge rank={debate.pro_rank_tier} />}
              {mySide === "pro" && <p className="text-xs text-arena-muted mt-1">You</p>}
            </div>

            <span className="text-2xl font-bold text-arena-muted">VS</span>

            {/* Con side */}
            <div className={`text-center ${mySide === "con" ? "ring-2 ring-arena-con rounded-xl p-4" : "p-4"}`}>
              <div className="w-16 h-16 bg-arena-con/20 rounded-full flex items-center justify-center mx-auto mb-2">
                <span className="text-2xl font-bold text-arena-con">C</span>
              </div>
              <p className="font-semibold text-arena-con">Con</p>
              <p className="text-sm">{debate.con_username || "Guest"}</p>
              {debate.con_rank_tier && <RankBadge rank={debate.con_rank_tier} />}
              {mySide === "con" && <p className="text-xs text-arena-muted mt-1">You</p>}
            </div>
          </div>

          <div className="flex items-center justify-center gap-4">
            <button
              onClick={handleSwap}
              className="px-6 py-2.5 border border-arena-border rounded-lg text-sm hover:bg-arena-border/30 transition-colors"
            >
              Swap Sides
            </button>
            <button
              onClick={handleStart}
              className="px-8 py-2.5 bg-arena-accent text-white rounded-lg text-sm font-medium hover:bg-arena-accent/80 transition-colors"
            >
              Ready — Start Debate
            </button>
          </div>
        </div>
      </div>
    );
  }

  // ─── LIVE DEBATE ─────────────────────────────────────
  if (debate.status === "in_progress") {
    const currentSpeaker = debate.phase?.includes("pro") ? "pro" : debate.phase?.includes("con") ? "con" : "both";

    return (
      <div className="max-w-4xl mx-auto px-4 py-6">
        {/* Top bar: topic + phase */}
        <div className="text-center mb-6">
          <h2 className="text-lg font-bold">{debate.topic_title || "Quick Match"}</h2>
          <div className="flex items-center justify-center gap-2 mt-1">
            {PHASE_ORDER.filter((p) => p !== "prematch").map((p) => (
              <div
                key={p}
                className={`w-2 h-2 rounded-full ${
                  p === debate.phase ? "bg-arena-accent" : PHASE_ORDER.indexOf(p) < PHASE_ORDER.indexOf(debate.phase) ? "bg-arena-accent/40" : "bg-arena-border"
                }`}
              />
            ))}
          </div>
        </div>

        {/* Timer */}
        <div className="flex justify-center mb-8">
          <PhaseTimer
            phase={debate.phase}
            timeLimit={debate.time_limit}
            onTimeUp={handleTimeUp}
          />
        </div>

        {/* Debaters */}
        <div className="grid grid-cols-2 gap-6 mb-8">
          {/* Pro */}
          <div className={`bg-arena-surface border rounded-xl p-4 ${
            currentSpeaker === "pro" || currentSpeaker === "both" ? "border-arena-pro" : "border-arena-border"
          }`}>
            <div className="flex items-center justify-between mb-3">
              <div>
                <span className="text-xs font-semibold text-arena-pro">PRO</span>
                <p className="font-medium text-sm">{debate.pro_username || "Guest"}</p>
              </div>
              <AudioLevelBar
                level={Object.values(daily.audioLevels)[0] || 0}
                side="pro"
              />
            </div>
            {(currentSpeaker === "pro" || currentSpeaker === "both") && (
              <p className="text-xs text-arena-pro animate-pulse">Speaking...</p>
            )}
          </div>

          {/* Con */}
          <div className={`bg-arena-surface border rounded-xl p-4 ${
            currentSpeaker === "con" || currentSpeaker === "both" ? "border-arena-con" : "border-arena-border"
          }`}>
            <div className="flex items-center justify-between mb-3">
              <div>
                <span className="text-xs font-semibold text-arena-con">CON</span>
                <p className="font-medium text-sm">{debate.con_username || "Guest"}</p>
              </div>
              <AudioLevelBar
                level={Object.values(daily.audioLevels)[1] || 0}
                side="con"
              />
            </div>
            {(currentSpeaker === "con" || currentSpeaker === "both") && (
              <p className="text-xs text-arena-con animate-pulse">Speaking...</p>
            )}
          </div>
        </div>

        {/* Controls */}
        <div className="flex items-center justify-center gap-4">
          <button
            onClick={daily.toggleMute}
            className={`px-6 py-2.5 rounded-lg text-sm font-medium transition-colors ${
              daily.localMuted
                ? "bg-arena-con/20 text-arena-con border border-arena-con"
                : "bg-arena-surface border border-arena-border hover:bg-arena-border/30"
            }`}
          >
            {daily.localMuted ? "Unmute" : "Mute"}
          </button>

          {!forfeitConfirm ? (
            <button
              onClick={() => setForfeitConfirm(true)}
              className="px-6 py-2.5 border border-arena-con/50 text-arena-con rounded-lg text-sm hover:bg-arena-con/10 transition-colors"
            >
              Forfeit
            </button>
          ) : (
            <div className="flex items-center gap-2">
              <span className="text-xs text-arena-con">Are you sure?</span>
              <button
                onClick={handleForfeit}
                className="px-4 py-2 bg-arena-con text-white rounded-lg text-sm"
              >
                Yes, forfeit
              </button>
              <button
                onClick={() => setForfeitConfirm(false)}
                className="px-4 py-2 border border-arena-border rounded-lg text-sm"
              >
                Cancel
              </button>
            </div>
          )}
        </div>
      </div>
    );
  }

  // ─── RESULTS ─────────────────────────────────────────
  if (debate.status === "completed" || debate.status === "forfeited") {
    const proScore = parseFloat(debate.pro_quality_score) || 0;
    const conScore = parseFloat(debate.con_quality_score) || 0;
    const analysis = debate.ai_qualitative_analysis;

    return (
      <div className="max-w-3xl mx-auto px-4 py-8">
        <div className="text-center mb-8">
          <p className="text-sm text-arena-muted mb-1">Debate Results</p>
          <h2 className="text-2xl font-bold">{debate.topic_title || "Quick Match"}</h2>
        </div>

        {/* Winner banner */}
        {debate.winner && (
          <div className={`text-center py-4 rounded-xl mb-8 ${
            debate.winner === "pro" ? "bg-arena-pro/10 border border-arena-pro/30" :
            debate.winner === "con" ? "bg-arena-con/10 border border-arena-con/30" :
            "bg-arena-accent/10 border border-arena-accent/30"
          }`}>
            <p className="text-lg font-bold">
              {debate.winner === "draw" ? "Draw!" : `${debate.winner === "pro" ? debate.pro_username || "Pro" : debate.con_username || "Con"} Wins!`}
            </p>
            <p className="text-xs text-arena-muted">
              {debate.winner_source === "forfeit" ? "by forfeit" : debate.winner_source === "ai" ? "AI decision" : "community vote"}
            </p>
          </div>
        )}

        {/* Score cards */}
        <div className="grid grid-cols-2 gap-6 mb-8">
          <div className="bg-arena-surface border border-arena-border rounded-xl p-6">
            <div className="flex items-center justify-between mb-4">
              <div>
                <span className="text-xs font-semibold text-arena-pro">PRO</span>
                <p className="font-medium">{debate.pro_username || "Guest"}</p>
              </div>
              <span className="text-3xl font-bold text-arena-pro">{proScore.toFixed(1)}</span>
            </div>
            {analysis?.pro && (
              <div className="space-y-2">
                <ScoreBar label="Coherence" score={analysis.pro.coherence || 0} color="pro" />
                <ScoreBar label="Evidence" score={analysis.pro.evidence || 0} color="pro" />
                <ScoreBar label="Engagement" score={analysis.pro.engagement || 0} color="pro" />
              </div>
            )}
          </div>

          <div className="bg-arena-surface border border-arena-border rounded-xl p-6">
            <div className="flex items-center justify-between mb-4">
              <div>
                <span className="text-xs font-semibold text-arena-con">CON</span>
                <p className="font-medium">{debate.con_username || "Guest"}</p>
              </div>
              <span className="text-3xl font-bold text-arena-con">{conScore.toFixed(1)}</span>
            </div>
            {analysis?.con && (
              <div className="space-y-2">
                <ScoreBar label="Coherence" score={analysis.con.coherence || 0} color="con" />
                <ScoreBar label="Evidence" score={analysis.con.evidence || 0} color="con" />
                <ScoreBar label="Engagement" score={analysis.con.engagement || 0} color="con" />
              </div>
            )}
          </div>
        </div>

        {/* AI Summary */}
        {analysis?.summary && (
          <div className="bg-arena-surface border border-arena-border rounded-xl p-6 mb-8">
            <h3 className="font-semibold mb-2">AI Analysis</h3>
            <p className="text-sm text-arena-muted leading-relaxed">{analysis.summary}</p>
          </div>
        )}

        {/* Community Vote */}
        <div className="bg-arena-surface border border-arena-border rounded-xl p-6 mb-8">
          <h3 className="font-semibold mb-4">Community Vote</h3>
          {user && !voted ? (
            <div className="flex items-center justify-center gap-4 mb-4">
              <button
                onClick={() => handleVote("pro")}
                className="px-6 py-2 bg-arena-pro/20 text-arena-pro border border-arena-pro/30 rounded-lg text-sm font-medium hover:bg-arena-pro/30 transition-colors"
              >
                Pro Wins
              </button>
              <button
                onClick={() => handleVote("draw")}
                className="px-6 py-2 bg-arena-border/30 text-arena-muted border border-arena-border rounded-lg text-sm font-medium hover:bg-arena-border/50 transition-colors"
              >
                Draw
              </button>
              <button
                onClick={() => handleVote("con")}
                className="px-6 py-2 bg-arena-con/20 text-arena-con border border-arena-con/30 rounded-lg text-sm font-medium hover:bg-arena-con/30 transition-colors"
              >
                Con Wins
              </button>
            </div>
          ) : voted ? (
            <p className="text-sm text-arena-muted text-center mb-4">Thanks for voting!</p>
          ) : (
            <p className="text-sm text-arena-muted text-center mb-4">Register to vote</p>
          )}
          {votes && (
            <VoteBar
              pro={votes.pro || 0}
              con={votes.con || 0}
              draw={votes.draw || 0}
            />
          )}
        </div>

        {/* Actions */}
        <div className="flex items-center justify-center gap-4">
          <button
            onClick={() => router.push("/")}
            className="px-6 py-2.5 border border-arena-border rounded-lg text-sm hover:bg-arena-border/30 transition-colors"
          >
            Back to Home
          </button>
        </div>
      </div>
    );
  }

  // Fallback for processing/cancelled states
  return (
    <div className="flex flex-col items-center justify-center min-h-[60vh] gap-4">
      <div className="w-10 h-10 border-4 border-arena-accent border-t-transparent rounded-full animate-spin" />
      <p className="text-arena-muted">Processing results...</p>
    </div>
  );
}
</file>

<file path="app/leaderboard/page.js">
import Link from "next/link";
import { createServiceClient } from "@/lib/supabase";
import RankBadge from "@/app/components/RankBadge";

export const dynamic = 'force-dynamic';

export async function generateMetadata() {
  return { title: "Leaderboard | Arena.gg" };
}

export default async function LeaderboardPage() {
  const db = createServiceClient();
  const { data: users } = await db
    .from("users")
    .select("id, username, rank_tier, quality_score_avg, wins, losses, draws, total_debates")
    .order("quality_score_avg", { ascending: false })
    .limit(50);

  return (
    <main className="max-w-4xl mx-auto px-4 pt-24 pb-12">
      <h1 className="text-2xl font-bold mb-1">Leaderboard</h1>
      <p className="text-sm text-arena-muted mb-6">Top 50 debaters by quality score</p>

      <div className="bg-arena-surface border border-arena-border rounded-xl overflow-hidden">
        <table className="w-full text-sm">
          <thead>
            <tr className="border-b border-arena-border text-arena-muted text-xs uppercase tracking-wide">
              <th className="text-left px-4 py-3 w-10">#</th>
              <th className="text-left px-4 py-3">Player</th>
              <th className="text-right px-4 py-3 hidden sm:table-cell">W / L / D</th>
              <th className="text-right px-4 py-3">Score</th>
            </tr>
          </thead>
          <tbody>
            {(users || []).map((user, i) => (
              <tr
                key={user.id}
                className="border-b border-arena-border/50 last:border-0 hover:bg-arena-border/20 transition-colors"
              >
                <td className="px-4 py-3 text-arena-muted font-mono">{i + 1}</td>
                <td className="px-4 py-3">
                  <div className="flex items-center gap-2">
                    <Link
                      href={`/profile/${user.id}`}
                      className="font-medium hover:text-arena-accent transition-colors"
                    >
                      {user.username}
                    </Link>
                    <RankBadge rank={user.rank_tier} />
                  </div>
                </td>
                <td className="px-4 py-3 text-right text-arena-muted hidden sm:table-cell">
                  <span className="text-arena-pro">{user.wins ?? 0}</span>
                  {" / "}
                  <span className="text-arena-con">{user.losses ?? 0}</span>
                  {" / "}
                  <span>{user.draws ?? 0}</span>
                </td>
                <td className="px-4 py-3 text-right font-mono font-medium">
                  {(user.quality_score_avg ?? 0).toFixed(1)}
                </td>
              </tr>
            ))}
            {(!users || users.length === 0) && (
              <tr>
                <td colSpan={4} className="px-4 py-8 text-center text-arena-muted">
                  No ranked players yet.
                </td>
              </tr>
            )}
          </tbody>
        </table>
      </div>
    </main>
  );
}
</file>

<file path="app/profile/page.js">
"use client";

import { useEffect } from "react";
import { useRouter } from "next/navigation";
import { useSession } from "@/lib/SessionContext";

export default function ProfileRedirect() {
  const router = useRouter();
  const { user, loading } = useSession();

  useEffect(() => {
    if (loading) return;
    if (user?.id) {
      router.replace(`/profile/${user.id}`);
    } else {
      router.replace("/");
    }
  }, [user, loading, router]);

  return (
    <div className="flex items-center justify-center min-h-[60vh]">
      <div className="w-10 h-10 border-4 border-arena-accent border-t-transparent rounded-full animate-spin" />
    </div>
  );
}
</file>

<file path="app/topics/TopicsFilter.js">
"use client";

import { useState } from "react";
import TopicCard from "../components/TopicCard";
import MatchmakingModal from "../components/MatchmakingModal";

const CATEGORIES = ["all", "politics", "economics", "philosophy", "science", "culture", "silly", "fantasy"];

export default function TopicsFilter({ topics }) {
  const [category, setCategory] = useState("all");
  const [selectedTopic, setSelectedTopic] = useState(null);

  const filtered =
    category === "all" ? topics : topics.filter((t) => t.category === category);

  return (
    <>
      {/* Category tabs */}
      <div className="flex gap-2 overflow-x-auto pb-4 mb-6">
        {CATEGORIES.map((cat) => (
          <button
            key={cat}
            onClick={() => setCategory(cat)}
            className={`px-4 py-2 rounded-lg text-sm font-medium whitespace-nowrap transition-colors ${
              category === cat
                ? "bg-arena-accent text-white"
                : "bg-arena-surface border border-arena-border text-arena-muted hover:text-arena-text"
            }`}
          >
            {cat.charAt(0).toUpperCase() + cat.slice(1)}
          </button>
        ))}
      </div>

      {/* Topic grid */}
      {filtered.length === 0 ? (
        <p className="text-center text-arena-muted py-16">No topics in this category.</p>
      ) : (
        <div className="grid sm:grid-cols-2 lg:grid-cols-3 gap-4">
          {filtered.map((topic) => (
            <TopicCard key={topic.id} topic={topic} onClick={setSelectedTopic} />
          ))}
        </div>
      )}

      <MatchmakingModal
        open={!!selectedTopic}
        onClose={() => setSelectedTopic(null)}
        topic={selectedTopic}
      />
    </>
  );
}
</file>

<file path="app/HomeHero.js">
"use client";

import { useState } from "react";
import MatchmakingModal from "./components/MatchmakingModal";

export default function HomeHero() {
  const [matchmakingOpen, setMatchmakingOpen] = useState(false);

  return (
    <>
      <button
        onClick={() => setMatchmakingOpen(true)}
        className="px-8 py-3 bg-arena-accent text-white rounded-lg font-semibold hover:bg-arena-accent/80 transition-colors text-lg"
      >
        Quick Match
      </button>
      <MatchmakingModal
        open={matchmakingOpen}
        onClose={() => setMatchmakingOpen(false)}
      />
    </>
  );
}
</file>

<file path="app/providers.js">
"use client";

import { SessionProvider } from "@/lib/SessionContext";
import { ToastProvider } from "./components/Toast";

export function Providers({ children }) {
  return (
    <SessionProvider>
      <ToastProvider>{children}</ToastProvider>
    </SessionProvider>
  );
}
</file>

<file path="lib/daily.js">
// ============================================================
// Daily.co Integration
// ============================================================
// Creates temporary rooms for debates and generates participant tokens.
// Rooms auto-expire after the debate time limit + buffer.
// Recording is enabled for post-debate transcription.
// ============================================================

const DAILY_API_BASE = "https://api.daily.co/v1";
const DAILY_DOMAIN = process.env.NEXT_PUBLIC_DAILY_DOMAIN || "verbalviol.daily.co";

function getApiKey() {
  const key = process.env.DAILY_API_KEY;
  if (!key) throw new Error("Missing DAILY_API_KEY");
  return key;
}

/**
 * Create a Daily.co room for a debate.
 * @param {string} debateId - Unique debate identifier (used as room name)
 * @param {number} timeLimitMinutes - Debate duration in minutes
 * @returns {Promise<{name: string, url: string, id: string}>}
 */
export async function createDailyRoom(debateId, timeLimitMinutes) {
  const roomName = `debate-${debateId}`;
  // Room expires 15 min after debate should end (buffer for post-debate)
  const expSeconds = (timeLimitMinutes + 15) * 60;
  const exp = Math.floor(Date.now() / 1000) + expSeconds;

  const res = await fetch(`${DAILY_API_BASE}/rooms`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${getApiKey()}`,
    },
    body: JSON.stringify({
      name: roomName,
      privacy: "private", // require token to join
      properties: {
        exp,
        max_participants: 2,
        enable_chat: false,
        enable_screenshare: false,
        enable_recording: "cloud", // records to Daily.co cloud
        start_audio_off: false,
        start_video_off: true, // audio-only debates
        eject_at_room_exp: true,
      },
    }),
  });

  if (!res.ok) {
    const err = await res.text();
    throw new Error(`Daily.co room creation failed: ${res.status} ${err}`);
  }

  const room = await res.json();
  return {
    name: room.name,
    url: room.url,
    id: room.id,
  };
}

/**
 * Generate a meeting token for a participant.
 * @param {string} roomName - Daily.co room name
 * @param {string} participantLabel - Display name (username or "Pro"/"Con")
 * @param {boolean} isOwner - Whether this participant can control recording
 * @returns {Promise<string>} Meeting token
 */
export async function createMeetingToken(roomName, participantLabel, isOwner = false) {
  const exp = Math.floor(Date.now() / 1000) + 7200; // 2 hour token expiry

  const res = await fetch(`${DAILY_API_BASE}/meeting-tokens`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${getApiKey()}`,
    },
    body: JSON.stringify({
      properties: {
        room_name: roomName,
        user_name: participantLabel,
        exp,
        is_owner: isOwner,
        enable_recording: isOwner ? "cloud" : undefined,
        start_audio_off: false,
        start_video_off: true,
      },
    }),
  });

  if (!res.ok) {
    const err = await res.text();
    throw new Error(`Daily.co token creation failed: ${res.status} ${err}`);
  }

  const data = await res.json();
  return data.token;
}

/**
 * Start cloud recording for a room.
 * Called when the debate transitions from prematch to opening_pro.
 * @param {string} roomName
 */
export async function startRecording(roomName) {
  const res = await fetch(`${DAILY_API_BASE}/rooms/${roomName}/recordings/start`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${getApiKey()}`,
    },
    body: JSON.stringify({
      // Record separate audio tracks per participant
      layout: { preset: "audio-only" },
    }),
  });

  // 409 means recording already started — that's fine
  if (!res.ok && res.status !== 409) {
    const err = await res.text();
    console.error(`Recording start failed: ${res.status} ${err}`);
  }
}

/**
 * Stop recording and get the recording access link.
 * @param {string} roomName
 * @returns {Promise<{id: string, download_url: string} | null>}
 */
export async function stopRecording(roomName) {
  const res = await fetch(`${DAILY_API_BASE}/rooms/${roomName}/recordings/stop`, {
    method: "POST",
    headers: {
      Authorization: `Bearer ${getApiKey()}`,
    },
  });

  if (!res.ok) {
    console.error(`Recording stop failed: ${res.status}`);
    return null;
  }

  return await res.json();
}

/**
 * Get recording access link after it's processed.
 * Daily.co takes a few minutes to process recordings.
 * @param {string} recordingId
 * @returns {Promise<{download_link: string} | null>}
 */
export async function getRecordingLink(recordingId) {
  const res = await fetch(`${DAILY_API_BASE}/recordings/${recordingId}/access-link`, {
    method: "GET",
    headers: {
      Authorization: `Bearer ${getApiKey()}`,
    },
  });

  if (!res.ok) return null;
  return await res.json();
}

/**
 * Delete a room after debate is complete and recording is saved.
 * @param {string} roomName
 */
export async function deleteDailyRoom(roomName) {
  await fetch(`${DAILY_API_BASE}/rooms/${roomName}`, {
    method: "DELETE",
    headers: {
      Authorization: `Bearer ${getApiKey()}`,
    },
  });
}
</file>

<file path="lib/deepgram.js">
// ============================================================
// Deepgram Transcription Service
// ============================================================
// Transcribes debate recordings into speaker-labeled segments.
// Uses Deepgram's Nova-2 model with diarization for speaker separation.
// ============================================================

const DEEPGRAM_API_BASE = "https://api.deepgram.com/v1";

function getApiKey() {
  const key = process.env.DEEPGRAM_API_KEY;
  if (!key) throw new Error("Missing DEEPGRAM_API_KEY");
  return key;
}

/**
 * Transcribe an audio file from a URL (e.g. Daily.co recording download link).
 * Returns structured transcript with speaker diarization.
 *
 * @param {string} audioUrl - Public URL to the audio file
 * @returns {Promise<{
 *   full_text: string,
 *   segments: Array<{speaker: number, start: number, end: number, text: string}>,
 *   duration: number
 * }>}
 */
export async function transcribeAudio(audioUrl) {
  const res = await fetch(`${DEEPGRAM_API_BASE}/listen`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Token ${getApiKey()}`,
    },
    body: JSON.stringify({
      url: audioUrl,
    }),
    // Query parameters for the transcription
    // Using URL params since Deepgram expects them
  });

  // Deepgram uses query params, let's use the full URL approach
  const url = new URL(`${DEEPGRAM_API_BASE}/listen`);
  url.searchParams.set("model", "nova-2");
  url.searchParams.set("smart_format", "true");
  url.searchParams.set("diarize", "true"); // speaker separation
  url.searchParams.set("punctuate", "true");
  url.searchParams.set("utterances", "true");
  url.searchParams.set("paragraphs", "true");

  const response = await fetch(url.toString(), {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Token ${getApiKey()}`,
    },
    body: JSON.stringify({ url: audioUrl }),
  });

  if (!response.ok) {
    const err = await response.text();
    throw new Error(`Deepgram transcription failed: ${response.status} ${err}`);
  }

  const data = await response.json();
  const result = data.results;

  // Extract utterances with speaker labels
  const utterances = result?.utterances || [];
  const segments = utterances.map((u) => ({
    speaker: u.speaker, // 0 or 1
    start: u.start,
    end: u.end,
    text: u.transcript,
    confidence: u.confidence,
  }));

  // Build full text with speaker labels
  const full_text = segments
    .map((s) => `[Speaker ${s.speaker}] ${s.text}`)
    .join("\n");

  // Get total duration
  const channels = result?.channels || [];
  const duration =
    channels[0]?.alternatives?.[0]?.paragraphs?.transcript
      ? segments.length > 0
        ? segments[segments.length - 1].end
        : 0
      : 0;

  return {
    full_text,
    segments,
    duration,
    raw: data, // keep raw response for debugging
  };
}

/**
 * Convert raw transcript segments into a labeled debate transcript.
 * Maps Deepgram speaker IDs (0, 1) to debate roles (Pro, Con).
 *
 * We determine which speaker is Pro vs Con based on who speaks first
 * (Pro always gives the first opening statement).
 *
 * @param {Array} segments - Deepgram transcript segments
 * @returns {{ pro_text: string, con_text: string, labeled_segments: Array, full_labeled_text: string }}
 */
export function labelTranscriptSpeakers(segments) {
  if (!segments || segments.length === 0) {
    return { pro_text: "", con_text: "", labeled_segments: [], full_labeled_text: "" };
  }

  // First speaker is always Pro (opening statement)
  const firstSpeaker = segments[0].speaker;
  const speakerMap = {
    [firstSpeaker]: "Pro",
    [firstSpeaker === 0 ? 1 : 0]: "Con",
  };

  const labeled = segments.map((s) => ({
    ...s,
    role: speakerMap[s.speaker] || `Speaker ${s.speaker}`,
  }));

  const pro_text = labeled
    .filter((s) => s.role === "Pro")
    .map((s) => s.text)
    .join(" ");

  const con_text = labeled
    .filter((s) => s.role === "Con")
    .map((s) => s.text)
    .join(" ");

  const full_labeled_text = labeled
    .map((s) => `[${s.role} @ ${formatTime(s.start)}] ${s.text}`)
    .join("\n");

  return { pro_text, con_text, labeled_segments: labeled, full_labeled_text };
}

function formatTime(seconds) {
  const m = Math.floor(seconds / 60);
  const s = Math.floor(seconds % 60);
  return `${m}:${s.toString().padStart(2, "0")}`;
}
</file>

<file path="lib/scoring.js">
// ============================================================
// AI Scoring System (Two-Tiered)
// ============================================================
// Tier 1: Procedural strike detection (high-precision, punitive)
// Tier 2: Qualitative debate scoring (exploratory, feedback)
//
// Both tiers run independently against the same transcript.
// Tier 1 flags are queued for admin review before strikes apply.
// ============================================================

import Anthropic from "@anthropic-ai/sdk";

function getClient() {
  const key = process.env.ANTHROPIC_API_KEY;
  if (!key) throw new Error("Missing ANTHROPIC_API_KEY");
  return new Anthropic({ apiKey: key });
}

// ============================================================
// TIER 1: Procedural Strike Detection
// ============================================================
const TIER1_SYSTEM_PROMPT = `You are a debate moderation system. Your job is to detect CLEAR, UNAMBIGUOUS rule violations in a debate transcript. You must be CONSERVATIVE — only flag violations you are highly confident about. False positives are far more damaging than false negatives.

You are detecting:
1. AD HOMINEM ATTACKS: Direct personal insults, name-calling, attacks on character rather than arguments. Saying "your argument is wrong" is NOT ad hominem. Saying "you're an idiot" IS.
2. SLURS AND HATE SPEECH: Racial, ethnic, gender, or sexuality-based slurs. Zero tolerance.
3. EXCESSIVE PROFANITY: Profanity used AGGRESSIVELY TOWARD THE OPPONENT. Casual profanity in argumentation (e.g., "that's a bullshit argument") is NOT flagged. Directed hostility (e.g., "fuck you, you piece of shit") IS flagged.
4. NON-PARTICIPATION: Extended silence (>30% of their allotted time), obvious non-engagement, or disruptive behavior.

CRITICAL RULES:
- Only flag what you are >90% confident about.
- Heated disagreement is NOT a violation.
- Passionate language is NOT a violation.
- Sarcasm is NOT a violation unless it crosses into personal attacks.
- If you are unsure, DO NOT FLAG.

Respond with ONLY valid JSON, no other text.`;

const TIER1_USER_PROMPT = (topic, transcript) => `Analyze this debate transcript for rule violations.

TOPIC: ${topic}

TRANSCRIPT:
${transcript}

Respond with this exact JSON structure:
{
  "pro_strikes": {
    "ad_hominem": false,
    "slurs": false,
    "excessive_profanity": false,
    "non_participation": false
  },
  "con_strikes": {
    "ad_hominem": false,
    "slurs": false,
    "excessive_profanity": false,
    "non_participation": false
  },
  "flagged_moments": [
    {
      "timestamp": "MM:SS",
      "speaker": "Pro or Con",
      "type": "ad_hominem|slurs|excessive_profanity|non_participation",
      "confidence": 0.0,
      "transcript_excerpt": "exact quote"
    }
  ],
  "notes": "Brief explanation of any flags, or 'No violations detected'"
}`;

/**
 * Run Tier 1 procedural strike detection.
 * @param {string} topic - Debate topic
 * @param {string} transcript - Full labeled transcript
 * @returns {Promise<Object>} Strike detection results
 */
export async function runTier1Analysis(topic, transcript) {
  const client = getClient();

  try {
    const response = await client.messages.create({
      model: "claude-sonnet-4-20250514",
      max_tokens: 1500,
      system: TIER1_SYSTEM_PROMPT,
      messages: [
        { role: "user", content: TIER1_USER_PROMPT(topic, transcript) },
      ],
    });

    const text = response.content[0]?.text || "{}";
    // Strip markdown fences if present
    const clean = text.replace(/```json\n?|```\n?/g, "").trim();
    return JSON.parse(clean);
  } catch (err) {
    console.error("Tier 1 analysis failed:", err);
    // Return safe default — no strikes on failure
    return {
      pro_strikes: { ad_hominem: false, slurs: false, excessive_profanity: false, non_participation: false },
      con_strikes: { ad_hominem: false, slurs: false, excessive_profanity: false, non_participation: false },
      flagged_moments: [],
      notes: "Analysis failed — defaulting to no violations",
      error: err.message,
    };
  }
}

// ============================================================
// TIER 2: Qualitative Debate Scoring
// ============================================================
const TIER2_SYSTEM_PROMPT = `You are an expert debate analyst. Your job is to evaluate the quality of both debaters' arguments. You are fair, specific, and constructive.

You evaluate three dimensions (each 0-100):
1. ARGUMENT COHERENCE: Were arguments logically structured? Did claims follow from premises? Were conclusions supported by the reasoning?
2. ENGAGEMENT WITH OPPONENT: Did the debater address their opponent's points directly? Did they respond to counterarguments, or talk past them?
3. EVIDENCE & REASONING: Were claims backed by evidence, examples, data, or sound logical reasoning? Or were they purely assertion?

OVERALL QUALITY is the equal-weighted average of the three dimensions.

Be specific in your strengths and areas_for_improvement — reference actual moments from the transcript with approximate timestamps.

Respond with ONLY valid JSON, no other text.`;

const TIER2_USER_PROMPT = (topic, transcript, timeLimit) => `Analyze this ${timeLimit}-minute debate.

TOPIC: ${topic}

TRANSCRIPT:
${transcript}

Respond with this exact JSON structure:
{
  "pro_player": {
    "coherence": 0,
    "engagement": 0,
    "evidence": 0,
    "overall_quality": 0,
    "strengths": ["specific strength with timestamp reference"],
    "areas_for_improvement": ["specific area with timestamp reference"]
  },
  "con_player": {
    "coherence": 0,
    "engagement": 0,
    "evidence": 0,
    "overall_quality": 0,
    "strengths": ["specific strength with timestamp reference"],
    "areas_for_improvement": ["specific area with timestamp reference"]
  },
  "debate_summary": "2-3 sentence summary of the debate's key arguments and turning points",
  "notable_moments": [
    {
      "timestamp": "MM:SS",
      "description": "What happened and why it mattered"
    }
  ]
}`;

/**
 * Run Tier 2 qualitative scoring.
 * @param {string} topic - Debate topic
 * @param {string} transcript - Full labeled transcript
 * @param {number} timeLimit - Debate time limit in minutes
 * @returns {Promise<Object>} Qualitative scoring results
 */
export async function runTier2Analysis(topic, transcript, timeLimit) {
  const client = getClient();

  try {
    const response = await client.messages.create({
      model: "claude-sonnet-4-20250514",
      max_tokens: 2000,
      system: TIER2_SYSTEM_PROMPT,
      messages: [
        { role: "user", content: TIER2_USER_PROMPT(topic, transcript, timeLimit) },
      ],
    });

    const text = response.content[0]?.text || "{}";
    const clean = text.replace(/```json\n?|```\n?/g, "").trim();
    const result = JSON.parse(clean);

    // Validate and compute overall if not provided
    for (const side of ["pro_player", "con_player"]) {
      const p = result[side];
      if (p) {
        p.coherence = clamp(p.coherence || 50);
        p.engagement = clamp(p.engagement || 50);
        p.evidence = clamp(p.evidence || 50);
        p.overall_quality = Math.round((p.coherence + p.engagement + p.evidence) / 3);
      }
    }

    return result;
  } catch (err) {
    console.error("Tier 2 analysis failed:", err);
    return {
      pro_player: defaultScores(),
      con_player: defaultScores(),
      debate_summary: "Analysis could not be completed.",
      notable_moments: [],
      error: err.message,
    };
  }
}

/**
 * Run both tiers and return combined results.
 * This is the main entry point called by the scoring pipeline.
 */
export async function runFullAnalysis(topic, transcript, timeLimit) {
  // Run both tiers in parallel
  const [tier1, tier2] = await Promise.all([
    runTier1Analysis(topic, transcript),
    runTier2Analysis(topic, transcript, timeLimit),
  ]);

  return {
    procedural: tier1,
    qualitative: tier2,
    analyzed_at: new Date().toISOString(),
  };
}

// Helpers
function clamp(val, min = 0, max = 100) {
  return Math.max(min, Math.min(max, Math.round(val)));
}

function defaultScores() {
  return {
    coherence: 50,
    engagement: 50,
    evidence: 50,
    overall_quality: 50,
    strengths: [],
    areas_for_improvement: ["Analysis could not be completed"],
  };
}
</file>

<file path="lib/supabase.js">
import { createClient } from "@supabase/supabase-js";

// Server-side client with service role (bypasses RLS)
// Used in API routes only — never expose to client
export function createServiceClient() {
  const url = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const key = process.env.SUPABASE_SERVICE_ROLE_KEY;
  if (!url || !key) {
    throw new Error("Missing SUPABASE env vars — check .env.local");
  }
  return createClient(url, key, {
    auth: { autoRefreshToken: false, persistSession: false },
  });
}

// Client-side Supabase (uses anon key, respects RLS)
export function createBrowserClient() {
  const url = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const key = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;
  if (!url || !key) {
    throw new Error("Missing NEXT_PUBLIC_SUPABASE env vars");
  }
  return createClient(url, key);
}
</file>

<file path="lib/useDaily.js">
// ============================================================
// useDaily — React hook for Daily.co audio calls
// ============================================================
// Wraps daily-js to provide a simple interface for the debate room:
// - Join/leave a call
// - Mute/unmute
// - Track participant state (who's connected, who's speaking)
// - Audio level monitoring for volume bars
// ============================================================

"use client";

import { useState, useEffect, useRef, useCallback } from "react";

/**
 * @param {Object} opts
 * @param {string} opts.roomUrl - Full Daily.co room URL
 * @param {string} opts.token - Meeting token for this participant
 * @param {boolean} opts.autoJoin - Join immediately on mount
 * @returns {Object} Daily call state and controls
 */
export function useDaily({ roomUrl, token, autoJoin = false }) {
  const callRef = useRef(null);
  const [state, setState] = useState({
    status: "idle", // idle, joining, joined, left, error
    participants: {}, // { participantId: { user_name, audio, video, local } }
    localMuted: false,
    error: null,
    audioLevels: {}, // { participantId: number 0-1 }
  });

  // Dynamically import daily-js (it's a heavy client-side only lib)
  const getDaily = useCallback(async () => {
    if (typeof window === "undefined") return null;
    const DailyIframe = (await import("@daily-co/daily-js")).default;
    return DailyIframe;
  }, []);

  const join = useCallback(async () => {
    if (callRef.current) return; // Already in a call

    const DailyIframe = await getDaily();
    if (!DailyIframe) return;

    setState((s) => ({ ...s, status: "joining" }));

    try {
      const call = DailyIframe.createCallObject({
        audioSource: true,
        videoSource: false, // Audio only
      });
      callRef.current = call;

      // Event handlers
      call.on("joined-meeting", (ev) => {
        setState((s) => ({
          ...s,
          status: "joined",
          participants: mapParticipants(call.participants()),
        }));
      });

      call.on("participant-joined", () => {
        setState((s) => ({
          ...s,
          participants: mapParticipants(call.participants()),
        }));
      });

      call.on("participant-updated", () => {
        setState((s) => ({
          ...s,
          participants: mapParticipants(call.participants()),
        }));
      });

      call.on("participant-left", () => {
        setState((s) => ({
          ...s,
          participants: mapParticipants(call.participants()),
        }));
      });

      call.on("error", (ev) => {
        console.error("Daily error:", ev);
        setState((s) => ({ ...s, status: "error", error: ev.errorMsg }));
      });

      call.on("left-meeting", () => {
        setState((s) => ({ ...s, status: "left" }));
        callRef.current = null;
      });

      // Join the room
      await call.join({
        url: roomUrl,
        token,
        startVideoOff: true,
        startAudioOff: false,
      });

      // Start audio level monitoring
      startAudioLevelMonitoring(call, setState);
    } catch (err) {
      console.error("Join failed:", err);
      setState((s) => ({ ...s, status: "error", error: err.message }));
    }
  }, [roomUrl, token, getDaily]);

  const leave = useCallback(async () => {
    if (callRef.current) {
      await callRef.current.leave();
      await callRef.current.destroy();
      callRef.current = null;
    }
  }, []);

  const toggleMute = useCallback(() => {
    if (!callRef.current) return;
    const newMuted = !state.localMuted;
    callRef.current.setLocalAudio(!newMuted);
    setState((s) => ({ ...s, localMuted: newMuted }));
  }, [state.localMuted]);

  const setMuted = useCallback((muted) => {
    if (!callRef.current) return;
    callRef.current.setLocalAudio(!muted);
    setState((s) => ({ ...s, localMuted: muted }));
  }, []);

  // Auto-join on mount if requested
  useEffect(() => {
    if (autoJoin && roomUrl && token) {
      join();
    }
    return () => {
      if (callRef.current) {
        callRef.current.leave().then(() => callRef.current?.destroy());
      }
    };
  }, [autoJoin, roomUrl, token, join]);

  return {
    ...state,
    join,
    leave,
    toggleMute,
    setMuted,
    callObject: callRef.current,
  };
}

/**
 * Map Daily.co participants to a simpler format.
 */
function mapParticipants(dailyParticipants) {
  const mapped = {};
  for (const [id, p] of Object.entries(dailyParticipants || {})) {
    mapped[id] = {
      id,
      user_name: p.user_name || "Unknown",
      audio: p.audio,
      video: p.video,
      local: p.local,
      joined_at: p.joined_at,
    };
  }
  return mapped;
}

/**
 * Monitor audio levels for volume bar visualization.
 * Uses requestAnimationFrame for smooth updates.
 */
function startAudioLevelMonitoring(call, setState) {
  let active = true;

  const poll = () => {
    if (!active || !call) return;

    try {
      const participants = call.participants();
      const levels = {};
      for (const [id, p] of Object.entries(participants)) {
        // Daily.co doesn't expose raw audio levels directly in all cases.
        // We approximate: if audio is on and they're not muted, assume speaking.
        // For real volume bars, you'd use the Web Audio API on the MediaStream.
        levels[id] = p.audio ? 0.3 + Math.random() * 0.4 : 0; // Simulated for now
      }
      setState((s) => ({ ...s, audioLevels: levels }));
    } catch (_) {}

    setTimeout(() => requestAnimationFrame(poll), 150);
  };

  requestAnimationFrame(poll);

  // Return cleanup function
  call.on("left-meeting", () => {
    active = false;
  });
}

export default useDaily;
</file>

<file path="lib/useRealtime.js">
// ============================================================
// useRealtimeMatch — Supabase realtime for matchmaking
// ============================================================
// Subscribes to queue updates and notifications so the client
// knows instantly when a match is found.
// ============================================================

"use client";

import { useState, useEffect, useCallback, useRef } from "react";
import { createBrowserClient } from "./supabase";

/**
 * Subscribe to matchmaking queue changes for a specific queue entry.
 * Fires callback when status changes to 'matched'.
 *
 * @param {string} queueId - The queue entry to watch
 * @param {Function} onMatch - Called with match data when matched
 */
export function useRealtimeMatch(queueId, onMatch) {
  const supabaseRef = useRef(null);

  useEffect(() => {
    if (!queueId) return;

    const supabase = createBrowserClient();
    supabaseRef.current = supabase;

    const channel = supabase
      .channel(`queue:${queueId}`)
      .on(
        "postgres_changes",
        {
          event: "UPDATE",
          schema: "public",
          table: "matchmaking_queue",
          filter: `id=eq.${queueId}`,
        },
        (payload) => {
          if (payload.new.status === "matched") {
            onMatch({
              debateId: payload.new.debate_id,
              matchedWith: payload.new.matched_with,
            });
          }
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [queueId, onMatch]);
}

/**
 * Subscribe to debate state changes (phase transitions, completion).
 *
 * @param {string} debateId
 * @param {Function} onChange - Called with updated debate data
 */
export function useRealtimeDebate(debateId, onChange) {
  useEffect(() => {
    if (!debateId) return;

    const supabase = createBrowserClient();

    const channel = supabase
      .channel(`debate:${debateId}`)
      .on(
        "postgres_changes",
        {
          event: "UPDATE",
          schema: "public",
          table: "debates",
          filter: `id=eq.${debateId}`,
        },
        (payload) => {
          onChange(payload.new);
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [debateId, onChange]);
}

/**
 * Subscribe to user notifications (match found, scoring complete, etc.)
 *
 * @param {string} userId
 * @param {Function} onNotification - Called with new notification
 */
export function useRealtimeNotifications(userId, onNotification) {
  useEffect(() => {
    if (!userId) return;

    const supabase = createBrowserClient();

    const channel = supabase
      .channel(`notifications:${userId}`)
      .on(
        "postgres_changes",
        {
          event: "INSERT",
          schema: "public",
          table: "notifications",
          filter: `user_id=eq.${userId}`,
        },
        (payload) => {
          onNotification(payload.new);
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [userId, onNotification]);
}

/**
 * Poll-based matchmaking fallback.
 * In case realtime subscription misses an update, poll every few seconds.
 * This is a safety net — realtime should handle 99% of cases.
 */
export function useMatchPolling(queueId, onMatch, intervalMs = 3000) {
  useEffect(() => {
    if (!queueId) return;

    const supabase = createBrowserClient();
    let active = true;

    const poll = async () => {
      if (!active) return;

      const { data } = await supabase
        .from("matchmaking_queue")
        .select("status, debate_id, matched_with")
        .eq("id", queueId)
        .single();

      if (data?.status === "matched") {
        onMatch({
          debateId: data.debate_id,
          matchedWith: data.matched_with,
        });
        return; // Stop polling
      }

      if (active) {
        setTimeout(poll, intervalMs);
      }
    };

    // Start polling after a short delay (give realtime a chance first)
    const timeout = setTimeout(poll, intervalMs);

    return () => {
      active = false;
      clearTimeout(timeout);
    };
  }, [queueId, onMatch, intervalMs]);
}
</file>

<file path=".env.example">
# ============================================================
# DEBATE PLATFORM — Environment Variables
# ============================================================
# Copy this to .env.local and fill in your values.
# NEVER commit .env.local to git.
# ============================================================

# --- Supabase ---
NEXT_PUBLIC_SUPABASE_URL=https://YOUR_PROJECT.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key-here
SUPABASE_SERVICE_ROLE_KEY=your-service-role-key-here

# --- Daily.co ---
DAILY_API_KEY=your-daily-api-key-here
NEXT_PUBLIC_DAILY_DOMAIN=verbalviol.daily.co

# --- Deepgram ---
DEEPGRAM_API_KEY=your-deepgram-api-key-here

# --- Anthropic ---
ANTHROPIC_API_KEY=your-anthropic-api-key-here
</file>

<file path="eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },
])
</file>

<file path="jsconfig.json">
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./*"]
    }
  }
}
</file>

<file path="middleware.js">
import { NextResponse } from "next/server";

// Routes that don't require session validation
const PUBLIC_ROUTES = ["/api/auth/session", "/api/auth/register"];

// Routes that require admin auth
const ADMIN_ROUTES = ["/api/scoring/trigger"];

export function middleware(request) {
  const { pathname } = request.nextUrl;

  // Only apply to API routes
  if (!pathname.startsWith("/api")) {
    return NextResponse.next();
  }

  // Skip for public routes
  if (PUBLIC_ROUTES.some((r) => pathname.startsWith(r))) {
    return NextResponse.next();
  }

  // Skip validation for GET requests
  if (request.method === "GET") {
    return NextResponse.next();
  }

  // Admin routes: check bearer token
  if (ADMIN_ROUTES.some((r) => pathname.startsWith(r))) {
    const adminSecret = process.env.ADMIN_SECRET;
    if (adminSecret) {
      const auth = request.headers.get("authorization");
      if (auth !== `Bearer ${adminSecret}`) {
        return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
      }
    }
    return NextResponse.next();
  }

  // For mutating requests, verify session token exists
  const sessionToken =
    request.cookies.get("debate_session")?.value ||
    request.headers.get("x-session-token");

  if (!sessionToken) {
    // Don't block — the API route itself will validate
    // This is a minimal beta check
    return NextResponse.next();
  }

  // Pass session token as header for API routes to consume
  const response = NextResponse.next();
  return response;
}

export const config = {
  matcher: ["/api/:path*"],
};
</file>

<file path="next.config.js">
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {},
};

module.exports = nextConfig;
</file>

<file path="postcss.config.mjs">
export default {
  plugins: {
    "@tailwindcss/postcss": {},
  },
};
</file>

<file path="README.md">
# Arena.gg — Debate Platform

Voice-based debate platform with matchmaking, AI scoring, and community voting.

## Stack

| Service | Purpose |
|---------|---------|
| Next.js 14 (App Router) | Frontend + API routes |
| Supabase | Postgres DB, auth, realtime subscriptions |
| Daily.co | WebRTC audio rooms (verbalviol.daily.co) |
| Deepgram | Speech-to-text transcription |
| Anthropic Claude | Two-tiered AI debate scoring |
| Vercel | Hosting |

## Project Structure

```
debate-platform/
├── app/api/
│   ├── auth/register/route.js      User registration + session migration
│   ├── auth/session/route.js       Guest session management
│   ├── matchmaking/queue/route.js  Enter/leave matchmaking queue
│   ├── daily/room/route.js         Get Daily.co room tokens
│   ├── debates/complete/route.js   Debate lifecycle (start/phase/complete/forfeit)
│   ├── scoring/trigger/route.js    Manual scoring trigger (admin)
│   ├── votes/cast/route.js         Cast votes + get tallies
│   └── profile/me/route.js         User profile + stats
├── lib/
│   ├── supabase.js        Supabase client (server + browser)
│   ├── daily.js           Daily.co server-side API (rooms, tokens, recording)
│   ├── deepgram.js        Deepgram transcription + speaker labeling
│   ├── scoring.js         Anthropic AI scoring (Tier 1 + Tier 2)
│   ├── matchmaking.js     Queue management + opponent matching
│   ├── pipeline.js        Post-debate orchestrator (record > transcribe > score > notify)
│   ├── api-client.js      Client-side fetch wrappers for all API routes
│   ├── useDaily.js        React hook for Daily.co audio calls
│   └── useRealtime.js     Supabase realtime hooks (match notifs, debate state)
├── supabase/
│   └── schema.sql         Full database schema + seed data
├── .env.example           Environment variable template
└── package.json
```

## Setup (20 minutes)

### 1. Clone and install

```bash
git clone <your-repo>
cd debate-platform
npm install
```

### 2. Set up Supabase database

1. Go to your Supabase project dashboard
2. Open SQL Editor
3. Paste the entire contents of `supabase/schema.sql` and run it
4. Creates all tables, indexes, RLS policies, realtime subscriptions, and seeds the topic database

### 3. Configure environment variables

```bash
cp .env.example .env.local
```

Fill in `.env.local`:

| Variable | Where to find it |
|----------|-----------------|
| NEXT_PUBLIC_SUPABASE_URL | Supabase > Settings > API > Project URL |
| NEXT_PUBLIC_SUPABASE_ANON_KEY | Supabase > Settings > API > anon/public key |
| SUPABASE_SERVICE_ROLE_KEY | Supabase > Settings > API > service_role key (secret) |
| DAILY_API_KEY | Daily.co > Developers > API Keys |
| NEXT_PUBLIC_DAILY_DOMAIN | Already set to verbalviol.daily.co |
| DEEPGRAM_API_KEY | Deepgram > API Keys |
| ANTHROPIC_API_KEY | Anthropic Console > API Keys |

### 4. Run locally

```bash
npm run dev
```

### 5. Deploy to Vercel

```bash
npm i -g vercel
vercel
```

Then add all env vars in Vercel dashboard: Project > Settings > Environment Variables.

Or connect your GitHub repo for auto-deploy on push.

## Data Flow

```
Quick Match click
  > POST /api/matchmaking/queue
    > enterQueue() writes to matchmaking_queue table
    > findMatch() checks for waiting opponents
    > Match found:
        > Creates debate record
        > Creates Daily.co room
        > Generates meeting tokens
        > Updates queue entries as "matched"
        > Sends in-app notification via Supabase realtime

Join debate room
  > POST /api/daily/room (get meeting token)
  > useDaily hook joins Daily.co call via WebRTC
  > Both participants hear each other
  > Phase timer runs client-side, synced via API

Debate ends
  > POST /api/debates/complete (action: "complete")
  > Pipeline kicks off async:
      1. Stop Daily.co recording
      2. Poll for download link (~2 min)
      3. Deepgram transcription with speaker diarization
      4. Map speakers to Pro/Con (first speaker = Pro)
      5. Tier 1: Claude checks for strikes (conservative)
      6. Tier 2: Claude scores argument quality (3 dimensions)
      7. Write scores to DB
      8. Update user quality_score_avg (80/20 recency weight)
      9. Notify participants
      10. Delete Daily.co room
```

## AI Scoring

### Tier 1 — Procedural Strike Detection
- Conservative, high-precision classifier
- Detects: ad hominem, slurs, aggressive profanity, non-participation
- All flags queued for admin review — no automated strikes
- Uses Claude Sonnet for speed

### Tier 2 — Qualitative Debate Scoring
- Coherence (0-100): logical structure, supported conclusions
- Engagement (0-100): addressed opponent's points directly
- Evidence (0-100): claims backed by reasoning/examples
- Overall = equal-weighted average
- Provides timestamped strengths and improvement areas

## API Reference

| Endpoint | Method | Purpose |
|----------|--------|---------|
| /api/auth/session | POST | Create/retrieve guest session |
| /api/auth/register | POST | Register user + migrate session |
| /api/matchmaking/queue | POST | Enter matchmaking queue |
| /api/matchmaking/queue | DELETE | Leave queue |
| /api/daily/room | POST | Get Daily.co room token |
| /api/debates/complete | POST | Debate lifecycle (start/phase/complete/forfeit) |
| /api/votes/cast | POST | Cast a vote |
| /api/votes/cast | GET | Get vote tally |
| /api/profile/me | GET | Get user profile + stats |
| /api/scoring/trigger | POST | Manually re-trigger scoring pipeline |

## What's Built vs. What's Next

### Built
- Full database schema with RLS and realtime
- Session-based guest access with 5-debate gate
- User registration with session migration
- Matchmaking engine (queue, matching, side assignment)
- Daily.co integration (room creation, tokens, recording)
- Deepgram transcription with speaker diarization
- Two-tiered AI scoring (procedural + qualitative)
- Post-debate pipeline (record > transcribe > score > notify)
- Community voting (unweighted, 1 user = 1 vote)
- User profiles with rank tiers
- Supabase realtime for instant match notifications
- Client-side API layer + Daily.co React hook
- React prototype UI (separate .jsx artifact)

### Next Steps
- Wire React UI to API routes (replace mock state with real API calls)
- Connect useDaily hook to debate room component
- Prematch lobby with Supabase realtime side-swap coordination
- Admin dashboard for strike review
- Async debates (Phase 2)
- Challenge system (Phase 2)
</file>

<file path="app/api/auth/register/route.js">
import { NextResponse } from "next/server";
import { createServiceClient } from "@/lib/supabase";

/**
 * POST /api/auth/register
 * Register a new user. Migrates session data if transitioning from guest.
 *
 * Body: { username, email, sessionId? }
 */
export async function POST(request) {
  try {
    const body = await request.json();
    const { username, email, password, sessionId } = body;

    if (!username || !email || !password) {
      return NextResponse.json({ error: "username, email, and password required" }, { status: 400 });
    }

    if (password.length < 8) {
      return NextResponse.json({ error: "Password must be at least 8 characters" }, { status: 400 });
    }

    // Validate username
    if (username.length < 3 || username.length > 24) {
      return NextResponse.json({ error: "Username must be 3-24 characters" }, { status: 400 });
    }
    if (!/^[a-zA-Z0-9_]+$/.test(username)) {
      return NextResponse.json({ error: "Username can only contain letters, numbers, and underscores" }, { status: 400 });
    }

    const db = createServiceClient();

    // Check username uniqueness
    const { data: existing } = await db
      .from("users")
      .select("id")
      .eq("username", username)
      .limit(1);

    if (existing && existing.length > 0) {
      return NextResponse.json({ error: "Username already taken" }, { status: 409 });
    }

    // Create Supabase auth user
    const { data: authData, error: authError } = await db.auth.admin.createUser({
      email,
      password,
      email_confirm: true, // skip email verification for MVP
      user_metadata: { username },
    });

    if (authError) {
      console.error("Auth creation failed:", authError);
      return NextResponse.json({ error: authError.message }, { status: 500 });
    }

    // Migrate session data if provided
    let migratedStrikes = 0;
    let migratedDebates = 0;
    if (sessionId) {
      const { data: session } = await db
        .from("sessions")
        .select("*")
        .eq("id", sessionId)
        .single();

      if (session) {
        migratedStrikes = session.strike_count || 0;
        migratedDebates = session.debate_count || 0;
      }
    }

    // Create user record
    const { data: user, error: userError } = await db
      .from("users")
      .insert({
        auth_id: authData.user.id,
        username,
        email,
        session_id: sessionId || null,
        total_debates: migratedDebates,
        strike_count: migratedStrikes,
        quality_score_avg: 50,
        rank_tier: "Bronze",
      })
      .select()
      .single();

    if (userError) {
      console.error("User creation failed:", userError);
      // Clean up auth user
      await db.auth.admin.deleteUser(authData.user.id);
      return NextResponse.json({ error: userError.message }, { status: 500 });
    }

    // Migrate debate ownership from session to user
    if (sessionId) {
      await db
        .from("debates")
        .update({ pro_user_id: user.id })
        .eq("pro_session_id", sessionId);

      await db
        .from("debates")
        .update({ con_user_id: user.id })
        .eq("con_session_id", sessionId);

      // Migrate strikes
      await db
        .from("strikes")
        .update({ user_id: user.id })
        .eq("session_id", sessionId);
    }

    return NextResponse.json({
      user: {
        id: user.id,
        username: user.username,
        quality_score: user.quality_score_avg,
        rank_tier: user.rank_tier,
        total_debates: user.total_debates,
        wins: user.wins,
        losses: user.losses,
        draws: user.draws,
      },
      auth_id: authData.user.id,
    });
  } catch (err) {
    console.error("Registration error:", err);
    return NextResponse.json({ error: err.message }, { status: 500 });
  }
}
</file>

<file path="app/api/debates/complete/route.js">
import { NextResponse } from "next/server";
import { waitUntil } from "@vercel/functions";
import { createServiceClient } from "@/lib/supabase";
import { startRecording } from "@/lib/daily";
import { processDebateCompletion, processDebateForfeit } from "@/lib/pipeline";

export const maxDuration = 300;

/**
 * POST /api/debates/complete
 * Handle debate lifecycle events: start, phase change, complete, forfeit.
 *
 * Body: { debateId, action, phase?, side? }
 * Actions: 'start', 'phase', 'complete', 'forfeit'
 */
export async function POST(request) {
  try {
    const body = await request.json();
    const { debateId, action, phase, side } = body;

    if (!debateId || !action) {
      return NextResponse.json({ error: "debateId and action required" }, { status: 400 });
    }

    const db = createServiceClient();

    switch (action) {
      // ---- START DEBATE ----
      case "start": {
        const { data: debate } = await db
          .from("debates")
          .select("daily_room_name")
          .eq("id", debateId)
          .single();

        // Start recording
        if (debate?.daily_room_name) {
          await startRecording(debate.daily_room_name).catch((err) =>
            console.error("Recording start failed:", err)
          );
        }

        await db
          .from("debates")
          .update({
            status: "in_progress",
            phase: "opening_pro",
            started_at: new Date().toISOString(),
          })
          .eq("id", debateId);

        return NextResponse.json({ success: true, phase: "opening_pro" });
      }

      // ---- PHASE TRANSITION ----
      case "phase": {
        if (!phase) {
          return NextResponse.json({ error: "phase required" }, { status: 400 });
        }

        const validPhases = [
          "opening_pro", "opening_con", "freeflow",
          "closing_con", "closing_pro", "ended",
        ];
        if (!validPhases.includes(phase)) {
          return NextResponse.json({ error: "Invalid phase" }, { status: 400 });
        }

        await db
          .from("debates")
          .update({ phase })
          .eq("id", debateId);

        // If phase is 'ended', trigger completion
        if (phase === "ended") {
          await db
            .from("debates")
            .update({
              status: "completed",
              completed_at: new Date().toISOString(),
            })
            .eq("id", debateId);

          // Trigger async processing pipeline — waitUntil keeps the function alive on Vercel
          waitUntil(
            processDebateCompletion(debateId).catch((err) => {
              console.error("Pipeline failed:", err);
              db.from("debates").update({ status: "pipeline_failed" }).eq("id", debateId);
            })
          );
        }

        return NextResponse.json({ success: true, phase });
      }

      // ---- COMPLETE ----
      case "complete": {
        await db
          .from("debates")
          .update({
            status: "completed",
            phase: "ended",
            completed_at: new Date().toISOString(),
          })
          .eq("id", debateId);

        // Trigger pipeline — waitUntil keeps the function alive on Vercel
        waitUntil(
          processDebateCompletion(debateId).catch((err) => {
            console.error("Pipeline failed:", err);
            db.from("debates").update({ status: "pipeline_failed" }).eq("id", debateId);
          })
        );

        return NextResponse.json({ success: true });
      }

      // ---- FORFEIT ----
      case "forfeit": {
        if (!side) {
          return NextResponse.json({ error: "side required for forfeit" }, { status: 400 });
        }

        waitUntil(
          processDebateForfeit(debateId, side).catch((err) => {
            console.error("Forfeit pipeline failed:", err);
            db.from("debates").update({ status: "pipeline_failed" }).eq("id", debateId);
          })
        );
        return NextResponse.json({ success: true, forfeited_by: side });
      }

      default:
        return NextResponse.json({ error: `Unknown action: ${action}` }, { status: 400 });
    }
  } catch (err) {
    console.error("Debate action error:", err);
    return NextResponse.json({ error: err.message }, { status: 500 });
  }
}
</file>

<file path="app/api/debates/detail/route.js">
import { NextResponse } from "next/server";
import { createServiceClient } from "@/lib/supabase";

/**
 * GET /api/debates/detail?debateId=<uuid>
 * Get full debate details including topic, scores, transcript status, and pipeline state.
 */
export async function GET(request) {
  try {
    const { searchParams } = new URL(request.url);
    const debateId = searchParams.get("debateId");

    if (!debateId) {
      return NextResponse.json({ error: "debateId required" }, { status: 400 });
    }

    const db = createServiceClient();

    const { data: debate, error } = await db
      .from("debates")
      .select(`
        *,
        topics(title, short_title, category, description),
        pro_user:users!pro_user_id(username, rank_tier),
        con_user:users!con_user_id(username, rank_tier)
      `)
      .eq("id", debateId)
      .single();

    if (error || !debate) {
      return NextResponse.json({ error: "Debate not found" }, { status: 404 });
    }

    // Get vote tally
    const { data: votes } = await db
      .from("votes")
      .select("winner_choice")
      .eq("debate_id", debateId);

    const voteTally = { pro: 0, con: 0, draw: 0, total: 0 };
    if (votes) {
      for (const v of votes) {
        voteTally[v.winner_choice] = (voteTally[v.winner_choice] || 0) + 1;
        voteTally.total++;
      }
    }

    return NextResponse.json({
      debate: {
        ...debate,
        // Flatten nested user joins
        topic_title: debate.topics?.title || null,
        topic_description: debate.topics?.description || null,
        pro_username: debate.pro_user?.username || null,
        pro_rank_tier: debate.pro_user?.rank_tier || null,
        con_username: debate.con_user?.username || null,
        con_rank_tier: debate.con_user?.rank_tier || null,
        // Strip raw transcript segments from public response (large payload)
        transcript: debate.transcript
          ? { full_text: debate.transcript.full_text, duration: debate.transcript.duration }
          : null,
      },
      voteTally,
    });
  } catch (err) {
    return NextResponse.json({ error: err.message }, { status: 500 });
  }
}
</file>

<file path="app/api/matchmaking/queue/route.js">
import { NextResponse } from "next/server";
import { enterQueue, leaveQueue } from "@/lib/matchmaking";
import { createServiceClient } from "@/lib/supabase";

/**
 * POST /api/matchmaking/queue
 * Enter the matchmaking queue.
 *
 * Body: { userId?, sessionId?, category, topicId?, timeLimit, stance, ranked }
 */
export async function POST(request) {
  try {
    const body = await request.json();
    const { userId, sessionId, category, topicId, timeLimit, stance, ranked } = body;

    if (!userId && !sessionId) {
      return NextResponse.json({ error: "Either userId or sessionId is required" }, { status: 400 });
    }

    if (!category || !timeLimit) {
      return NextResponse.json({ error: "category and timeLimit are required" }, { status: 400 });
    }

    // Validate unregistered user debate limit
    if (!userId && sessionId) {
      const db = createServiceClient();
      const { data: session } = await db
        .from("sessions")
        .select("debate_count")
        .eq("id", sessionId)
        .single();

      if (session && session.debate_count >= 5) {
        return NextResponse.json(
          { error: "Guest limit reached. Please register to continue." },
          { status: 403 }
        );
      }
    }

    // Ranked requires registration
    if (ranked && !userId) {
      return NextResponse.json(
        { error: "Ranked matchmaking requires registration." },
        { status: 403 }
      );
    }

    const result = await enterQueue({
      userId: userId || null,
      sessionId: sessionId || null,
      category,
      topicId: topicId || null,
      timeLimit: parseInt(timeLimit),
      stance: stance || "either",
      ranked: !!ranked,
    });

    return NextResponse.json(result);
  } catch (err) {
    console.error("Queue error:", err);
    return NextResponse.json({ error: err.message }, { status: 500 });
  }
}

/**
 * DELETE /api/matchmaking/queue
 * Leave the matchmaking queue.
 *
 * Body: { queueId }
 */
export async function DELETE(request) {
  try {
    const body = await request.json();
    const { queueId } = body;

    if (!queueId) {
      return NextResponse.json({ error: "queueId required" }, { status: 400 });
    }

    await leaveQueue(queueId);
    return NextResponse.json({ success: true });
  } catch (err) {
    return NextResponse.json({ error: err.message }, { status: 500 });
  }
}
</file>

<file path="app/api/og/profile/route.js">
import { ImageResponse } from "next/og";
import { getProfileSSR } from "@/lib/queries/getProfileSSR";

export async function GET(request) {
  const { searchParams } = new URL(request.url);
  const userId = searchParams.get("userId");

  if (!userId) {
    return new Response("Missing userId", { status: 400 });
  }

  const profile = await getProfileSSR(userId);

  if (!profile) {
    return new Response("Profile not found", { status: 404 });
  }

  const username = profile.username || "Debater";
  const rankTier = profile.rank_tier || "Bronze";
  const wins = profile.wins || 0;
  const losses = profile.losses || 0;
  const draws = profile.draws || 0;
  const totalDebates = profile.total_debates || 0;
  const qualityScore = parseFloat(
    profile.quality_score_avg || profile.quality_score || 50
  ).toFixed(1);

  // Rank tier color mapping
  const rankColors = {
    Bronze: "#cd7f32",
    Silver: "#9ca3af",
    Gold: "#f59e0b",
    Platinum: "#67e8f9",
    Diamond: "#818cf8",
  };
  const rankColor = rankColors[rankTier] || "#FF6B35";

  const image = new ImageResponse(
    (
      <div
        style={{
          display: "flex",
          flexDirection: "column",
          width: "100%",
          height: "100%",
          backgroundColor: "#FAF8F5",
          padding: "56px 64px",
          fontFamily: "system-ui, -apple-system, sans-serif",
        }}
      >
        {/* Header */}
        <div
          style={{
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
            marginBottom: "48px",
          }}
        >
          <div
            style={{
              fontSize: "24px",
              fontWeight: "800",
              color: "#FF6B35",
            }}
          >
            Arena.gg
          </div>
          <div
            style={{
              backgroundColor: rankColor + "20",
              border: `1px solid ${rankColor}50`,
              borderRadius: "20px",
              padding: "6px 18px",
              fontSize: "14px",
              fontWeight: "700",
              color: rankColor,
            }}
          >
            {rankTier}
          </div>
        </div>

        {/* Avatar + username */}
        <div
          style={{
            display: "flex",
            alignItems: "center",
            gap: "28px",
            marginBottom: "48px",
          }}
        >
          <div
            style={{
              width: "96px",
              height: "96px",
              borderRadius: "50%",
              backgroundColor: "#FF6B3520",
              border: "2px solid #FF6B3540",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              fontSize: "40px",
              fontWeight: "800",
              color: "#FF6B35",
            }}
          >
            {username[0].toUpperCase()}
          </div>
          <div style={{ display: "flex", flexDirection: "column", gap: "6px" }}>
            <div
              style={{
                fontSize: "14px",
                color: "#6B7280",
                fontWeight: "500",
              }}
            >
              @{username}
            </div>
            <div
              style={{
                fontSize: "42px",
                fontWeight: "800",
                color: "#1A1A1A",
                lineHeight: "1",
              }}
            >
              {username}
            </div>
          </div>
        </div>

        {/* Stats row */}
        <div style={{ display: "flex", gap: "20px", flex: 1 }}>
          {[
            { label: "Debates", value: totalDebates, color: "#1A1A1A" },
            { label: "Wins", value: wins, color: "#22c55e" },
            { label: "Losses", value: losses, color: "#ef4444" },
            { label: "Draws", value: draws, color: "#9CA3AF" },
          ].map((stat) => (
            <div
              key={stat.label}
              style={{
                flex: 1,
                backgroundColor: "#FFFFFF",
                border: "1px solid #E8DDD0",
                borderRadius: "16px",
                padding: "20px",
                display: "flex",
                flexDirection: "column",
                alignItems: "center",
                gap: "6px",
              }}
            >
              <div
                style={{
                  fontSize: "36px",
                  fontWeight: "800",
                  color: stat.color,
                }}
              >
                {stat.value}
              </div>
              <div style={{ fontSize: "13px", color: "#6B7280", fontWeight: "500" }}>
                {stat.label}
              </div>
            </div>
          ))}
        </div>

        {/* Quality score bar */}
        <div
          style={{
            marginTop: "24px",
            display: "flex",
            alignItems: "center",
            gap: "16px",
          }}
        >
          <div style={{ fontSize: "14px", color: "#6B7280", fontWeight: "500", minWidth: "120px" }}>
            Quality Score
          </div>
          <div
            style={{
              flex: 1,
              height: "10px",
              backgroundColor: "#E8DDD0",
              borderRadius: "5px",
              overflow: "hidden",
            }}
          >
            <div
              style={{
                width: `${qualityScore}%`,
                height: "100%",
                backgroundColor: "#FF6B35",
                borderRadius: "5px",
              }}
            />
          </div>
          <div
            style={{
              fontSize: "20px",
              fontWeight: "700",
              color: "#FF6B35",
              minWidth: "48px",
              textAlign: "right",
            }}
          >
            {qualityScore}
          </div>
        </div>
      </div>
    ),
    {
      width: 1200,
      height: 630,
      headers: {
        "Cache-Control": "public, max-age=300, s-maxage=3600, stale-while-revalidate=86400",
      },
    }
  );

  return image;
}
</file>

<file path="app/api/og/route.js">
import { ImageResponse } from "next/og";
import { getDebateSSR } from "@/lib/queries/getDebateSSR";

export async function GET(request) {
  const { searchParams } = new URL(request.url);
  const debateId = searchParams.get("debateId");

  if (!debateId) {
    return new Response("Missing debateId", { status: 400 });
  }

  const debate = await getDebateSSR(debateId);

  if (!debate) {
    return new Response("Debate not found", { status: 404 });
  }

  const topicTitle =
    debate.topics?.title || debate.topic_title || "Quick Match";
  const category = debate.topics?.category || debate.category || null;
  const proName = debate.pro_username || "Pro";
  const conName = debate.con_username || "Con";
  const proRank = debate.pro_rank_tier || null;
  const conRank = debate.con_rank_tier || null;
  const isCompleted =
    debate.status === "completed" || debate.status === "forfeited";
  const isLive = debate.status === "in_progress";
  const proScore = isCompleted
    ? parseFloat(debate.pro_quality_score || 0).toFixed(1)
    : null;
  const conScore = isCompleted
    ? parseFloat(debate.con_quality_score || 0).toFixed(1)
    : null;
  const winner = debate.winner || null;
  const winnerName =
    winner === "pro" ? proName : winner === "con" ? conName : null;

  // Cache headers: longer for completed debates
  const cacheControl = isCompleted
    ? "public, max-age=3600, s-maxage=86400, stale-while-revalidate=86400"
    : "public, max-age=0, s-maxage=0, no-cache";

  const image = new ImageResponse(
    (
      <div
        style={{
          display: "flex",
          flexDirection: "column",
          width: "100%",
          height: "100%",
          backgroundColor: "#FAF8F5",
          padding: "48px 56px",
          fontFamily: "system-ui, -apple-system, sans-serif",
        }}
      >
        {/* Header row: branding + category badge */}
        <div
          style={{
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
            marginBottom: "32px",
          }}
        >
          <div
            style={{
              fontSize: "26px",
              fontWeight: "800",
              color: "#FF6B35",
              letterSpacing: "-0.5px",
            }}
          >
            Arena.gg
          </div>
          <div style={{ display: "flex", alignItems: "center", gap: "12px" }}>
            {isLive && (
              <div
                style={{
                  display: "flex",
                  alignItems: "center",
                  gap: "8px",
                  backgroundColor: "#22c55e20",
                  border: "1px solid #22c55e50",
                  borderRadius: "20px",
                  padding: "6px 14px",
                }}
              >
                <div
                  style={{
                    width: "8px",
                    height: "8px",
                    borderRadius: "50%",
                    backgroundColor: "#22c55e",
                  }}
                />
                <span
                  style={{
                    fontSize: "13px",
                    fontWeight: "700",
                    color: "#22c55e",
                    letterSpacing: "0.08em",
                  }}
                >
                  LIVE
                </span>
              </div>
            )}
            {category && (
              <div
                style={{
                  backgroundColor: "#FF6B3515",
                  border: "1px solid #FF6B3530",
                  borderRadius: "20px",
                  padding: "6px 16px",
                  fontSize: "13px",
                  fontWeight: "600",
                  color: "#FF6B35",
                }}
              >
                {category.charAt(0).toUpperCase() + category.slice(1)}
              </div>
            )}
          </div>
        </div>

        {/* Topic title */}
        <div
          style={{
            fontSize: "13px",
            fontWeight: "600",
            color: "#6B7280",
            letterSpacing: "0.08em",
            marginBottom: "10px",
          }}
        >
          TOPIC
        </div>
        <div
          style={{
            fontSize: topicTitle.length > 60 ? "32px" : "40px",
            fontWeight: "700",
            color: "#1A1A1A",
            lineHeight: "1.2",
            marginBottom: "36px",
            flex: 1,
          }}
        >
          {topicTitle}
        </div>

        {/* Pro vs Con cards */}
        <div style={{ display: "flex", gap: "16px", alignItems: "stretch" }}>
          {/* Pro card */}
          <div
            style={{
              flex: 1,
              backgroundColor: "#FFFFFF",
              border: `1px solid ${winner === "pro" ? "#22c55e" : "#E8DDD0"}`,
              borderRadius: "16px",
              padding: "20px 24px",
              display: "flex",
              flexDirection: "column",
              gap: "6px",
              position: "relative",
            }}
          >
            {winner === "pro" && (
              <div
                style={{
                  position: "absolute",
                  top: "-12px",
                  left: "50%",
                  transform: "translateX(-50%)",
                  backgroundColor: "#22c55e",
                  color: "#fff",
                  fontSize: "11px",
                  fontWeight: "700",
                  padding: "3px 10px",
                  borderRadius: "10px",
                  letterSpacing: "0.05em",
                }}
              >
                WINNER
              </div>
            )}
            <div
              style={{
                fontSize: "11px",
                fontWeight: "700",
                color: "#22c55e",
                letterSpacing: "0.1em",
              }}
            >
              PRO
            </div>
            <div
              style={{
                fontSize: "22px",
                fontWeight: "700",
                color: "#1A1A1A",
              }}
            >
              {proName}
            </div>
            {proRank && (
              <div style={{ fontSize: "13px", color: "#9CA3AF" }}>{proRank}</div>
            )}
            {proScore && (
              <div
                style={{
                  fontSize: "36px",
                  fontWeight: "800",
                  color: "#22c55e",
                  marginTop: "4px",
                }}
              >
                {proScore}
              </div>
            )}
          </div>

          {/* VS divider */}
          <div
            style={{
              display: "flex",
              alignItems: "center",
              fontSize: "20px",
              fontWeight: "700",
              color: "#9CA3AF",
              padding: "0 4px",
            }}
          >
            VS
          </div>

          {/* Con card */}
          <div
            style={{
              flex: 1,
              backgroundColor: "#FFFFFF",
              border: `1px solid ${winner === "con" ? "#ef4444" : "#E8DDD0"}`,
              borderRadius: "16px",
              padding: "20px 24px",
              display: "flex",
              flexDirection: "column",
              gap: "6px",
              position: "relative",
            }}
          >
            {winner === "con" && (
              <div
                style={{
                  position: "absolute",
                  top: "-12px",
                  left: "50%",
                  transform: "translateX(-50%)",
                  backgroundColor: "#ef4444",
                  color: "#fff",
                  fontSize: "11px",
                  fontWeight: "700",
                  padding: "3px 10px",
                  borderRadius: "10px",
                  letterSpacing: "0.05em",
                }}
              >
                WINNER
              </div>
            )}
            <div
              style={{
                fontSize: "11px",
                fontWeight: "700",
                color: "#ef4444",
                letterSpacing: "0.1em",
              }}
            >
              CON
            </div>
            <div
              style={{
                fontSize: "22px",
                fontWeight: "700",
                color: "#1A1A1A",
              }}
            >
              {conName}
            </div>
            {conRank && (
              <div style={{ fontSize: "13px", color: "#9CA3AF" }}>{conRank}</div>
            )}
            {conScore && (
              <div
                style={{
                  fontSize: "36px",
                  fontWeight: "800",
                  color: "#ef4444",
                  marginTop: "4px",
                }}
              >
                {conScore}
              </div>
            )}
          </div>
        </div>

        {/* Draw banner */}
        {winner === "draw" && (
          <div
            style={{
              marginTop: "20px",
              backgroundColor: "#FF6B3515",
              border: "1px solid #FF6B3530",
              borderRadius: "12px",
              padding: "12px 24px",
              textAlign: "center",
              display: "flex",
              justifyContent: "center",
            }}
          >
            <span
              style={{
                fontSize: "16px",
                fontWeight: "700",
                color: "#FF6B35",
              }}
            >
              Draw — Both debaters performed equally
            </span>
          </div>
        )}
      </div>
    ),
    {
      width: 1200,
      height: 630,
      headers: {
        "Cache-Control": cacheControl,
      },
    }
  );

  return image;
}
</file>

<file path="app/api/profile/me/route.js">
import { NextResponse } from "next/server";
import { createServiceClient } from "@/lib/supabase";

/**
 * GET /api/profile/me?userId=xxx
 * Get current user's profile with stats and recent debates.
 */
export async function GET(request) {
  try {
    const { searchParams } = new URL(request.url);
    const userId = searchParams.get("userId");

    if (!userId) {
      return NextResponse.json({ error: "userId required" }, { status: 400 });
    }

    const db = createServiceClient();

    // Get user
    const { data: user, error } = await db
      .from("users")
      .select("*")
      .eq("id", userId)
      .single();

    if (error || !user) {
      return NextResponse.json({ error: "User not found" }, { status: 404 });
    }

    // Get recent debates with user joins for DebateCard compatibility
    const { data: debates } = await db
      .from("debates")
      .select("id, winner, created_at, completed_at, topics(title, short_title), pro_user:users!pro_user_id(username), con_user:users!con_user_id(username)")
      .or(`pro_user_id.eq.${userId},con_user_id.eq.${userId}`)
      .eq("status", "completed")
      .order("completed_at", { ascending: false })
      .limit(20);

    // Get notification count
    const { count: unreadNotifs } = await db
      .from("notifications")
      .select("id", { count: "exact", head: true })
      .eq("user_id", userId)
      .eq("read", false);

    // Get pending challenges
    const { count: pendingChallenges } = await db
      .from("challenges")
      .select("id", { count: "exact", head: true })
      .eq("target_id", userId)
      .eq("status", "pending");

    return NextResponse.json({
      user: {
        id: user.id,
        username: user.username,
        quality_score: user.quality_score_avg,
        rank_tier: user.rank_tier,
        total_debates: user.total_debates,
        wins: user.wins,
        losses: user.losses,
        draws: user.draws,
        strike_count: user.strike_count,
        created_at: user.created_at,
      },
      recent_debates: (debates || []).map((d) => ({
        id: d.id,
        status: "completed",
        created_at: d.completed_at || d.created_at,
        topic_title: d.topics?.short_title || d.topics?.title || null,
        pro_username: d.pro_user?.username || null,
        con_username: d.con_user?.username || null,
        winner: d.winner,
      })),
      unread_notifications: unreadNotifs || 0,
      pending_challenges: pendingChallenges || 0,
    });
  } catch (err) {
    return NextResponse.json({ error: err.message }, { status: 500 });
  }
}
</file>

<file path="app/api/scoring/trigger/route.js">
import { NextResponse } from "next/server";
import { processDebateCompletion, retryFailedSteps } from "@/lib/pipeline";

/**
 * POST /api/scoring/trigger
 * Trigger or retry the scoring pipeline for a debate.
 *
 * Body: { debateId, retry?: boolean }
 */
export async function POST(request) {
  try {
    const body = await request.json();
    const { debateId, retry } = body;

    if (!debateId) {
      return NextResponse.json({ error: "debateId required" }, { status: 400 });
    }

    if (retry) {
      // Retry only failed steps
      const result = await retryFailedSteps(debateId);
      return NextResponse.json({
        success: result.success,
        failedSteps: result.failedSteps || [],
        message: result.error || (result.success
          ? "Retry completed successfully"
          : `Retry completed with failures: ${result.failedSteps?.join(", ")}`),
      });
    }

    // Full pipeline run (non-blocking)
    processDebateCompletion(debateId).catch((err) =>
      console.error(`Manual pipeline trigger failed for ${debateId}:`, err)
    );

    return NextResponse.json({
      success: true,
      message: `Pipeline triggered for debate ${debateId}. Processing in background.`,
    });
  } catch (err) {
    return NextResponse.json({ error: err.message }, { status: 500 });
  }
}
</file>

<file path="app/components/DebateCard.js">
"use client";

import Link from "next/link";
import RankBadge from "./RankBadge";

export default function DebateCard({ debate }) {
  const isCompleted = debate.status === "completed";

  return (
    <Link
      href={`/debate/${debate.id}`}
      className="block bg-arena-card border border-arena-border rounded-xl p-4 hover:border-arena-accent hover:shadow-sm transition-all"
    >
      <div className="flex items-center justify-between mb-2">
        <span className="text-xs text-arena-muted">
          {new Date(debate.created_at).toLocaleDateString()}
        </span>
        <span className={`text-xs px-2 py-0.5 rounded-full ${
          isCompleted ? "bg-emerald-100 text-emerald-700" : "bg-amber-100 text-amber-700"
        }`}>
          {debate.status}
        </span>
      </div>

      <p className="font-medium text-sm mb-2">{debate.topic_title || "Quick Match"}</p>

      <div className="flex items-center justify-between text-xs">
        <div className="flex items-center gap-2">
          <span className="text-arena-pro">PRO</span>
          <span>{debate.pro_username || "Guest"}</span>
        </div>
        <span className="text-arena-muted">vs</span>
        <div className="flex items-center gap-2">
          <span>{debate.con_username || "Guest"}</span>
          <span className="text-arena-con">CON</span>
        </div>
      </div>

      {isCompleted && debate.winner && (
        <div className="mt-2 text-xs text-center">
          Winner: <span className={debate.winner === "pro" ? "text-arena-pro" : debate.winner === "con" ? "text-arena-con" : "text-arena-muted"}>
            {debate.winner === "draw" ? "Draw" : debate.winner.toUpperCase()}
          </span>
        </div>
      )}
    </Link>
  );
}
</file>

<file path="app/components/Nav.js">
"use client";

import { useState } from "react";
import Link from "next/link";
import { useSession } from "@/lib/SessionContext";
import NotificationDropdown from "./NotificationDropdown";
import RegisterModal from "./RegisterModal";
import LoginModal from "./LoginModal";
import RankBadge from "./RankBadge";

export default function Nav() {
  const { user, session, loading, logout } = useSession();
  const [registerOpen, setRegisterOpen] = useState(false);
  const [loginOpen, setLoginOpen] = useState(false);
  const [menuOpen, setMenuOpen] = useState(false);

  const isGuest = !user;
  const debatesRemaining = 5 - (session?.debate_count || 0);

  return (
    <>
      <nav className="fixed top-0 left-0 right-0 z-40 bg-arena-bg/90 backdrop-blur-md border-b border-arena-border">
        <div className="max-w-6xl mx-auto px-4 h-16 flex items-center justify-between">
          {/* Left: Logo */}
          <Link href="/" className="flex items-center gap-2 font-bold text-lg">
            <span className="text-arena-accent">Arena</span>
            <span className="text-arena-muted">.gg</span>
          </Link>

          {/* Center: Nav links */}
          <div className="hidden sm:flex items-center gap-6">
            <Link href="/" className="text-sm text-arena-muted hover:text-arena-text transition-colors">
              Home
            </Link>
            <Link href="/topics" className="text-sm text-arena-muted hover:text-arena-text transition-colors">
              Topics
            </Link>
            <Link href="/leaderboard" className="text-sm text-arena-muted hover:text-arena-text transition-colors">
              Leaderboard
            </Link>
          </div>

          {/* Right: User area */}
          <div className="flex items-center gap-3">
            {!loading && (
              <>
                {user && <NotificationDropdown />}

                {isGuest ? (
                  <div className="flex items-center gap-3">
                    <span className="hidden sm:inline text-xs text-arena-muted">
                      {debatesRemaining > 0
                        ? `${debatesRemaining} debates remaining`
                        : "No debates remaining"}
                    </span>
                    <button
                      onClick={() => setLoginOpen(true)}
                      className="text-sm text-arena-muted hover:text-arena-text transition-colors"
                    >
                      Sign In
                    </button>
                    <button
                      onClick={() => setRegisterOpen(true)}
                      className="px-3 py-1.5 bg-arena-accent text-white text-sm rounded-lg font-medium hover:bg-arena-accent/80 transition-colors"
                    >
                      Register
                    </button>
                  </div>
                ) : (
                  <div className="relative" ref={(el) => {
                    // Close menu on outside click
                    if (!el) return;
                    const handler = (e) => {
                      if (!el.contains(e.target)) setMenuOpen(false);
                    };
                    document.addEventListener("mousedown", handler);
                  }}>
                    <button
                      onClick={() => setMenuOpen(!menuOpen)}
                      className="flex items-center gap-2 text-sm hover:text-arena-accent transition-colors"
                    >
                      <span>{user.username}</span>
                      <RankBadge rank={user.rank_tier} />
                    </button>
                    {menuOpen && (
                      <div className="absolute right-0 mt-2 w-48 bg-arena-surface border border-arena-border rounded-lg shadow-xl py-1">
                        <Link
                          href={`/profile/${user.id}`}
                          onClick={() => setMenuOpen(false)}
                          className="block px-4 py-2 text-sm hover:bg-arena-border/30"
                        >
                          Profile
                        </Link>
                        <button
                          onClick={() => { setMenuOpen(false); logout(); }}
                          className="block w-full text-left px-4 py-2 text-sm text-arena-con hover:bg-arena-border/30"
                        >
                          Sign Out
                        </button>
                      </div>
                    )}
                  </div>
                )}
              </>
            )}

            {/* Mobile menu toggle */}
            <button
              onClick={() => setMenuOpen(!menuOpen)}
              className="sm:hidden p-2 text-arena-muted hover:text-arena-text"
            >
              <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
                <path strokeLinecap="round" strokeLinejoin="round" d="M4 6h16M4 12h16M4 18h16" />
              </svg>
            </button>
          </div>
        </div>
      </nav>

      <RegisterModal open={registerOpen} onClose={() => setRegisterOpen(false)} />
      <LoginModal open={loginOpen} onClose={() => setLoginOpen(false)} />
    </>
  );
}
</file>

<file path="app/components/RankBadge.js">
"use client";

const RANK_STYLES = {
  Bronze: "bg-amber-100 text-amber-700 border-amber-300",
  Silver: "bg-gray-100 text-gray-600 border-gray-300",
  Gold: "bg-yellow-100 text-yellow-700 border-yellow-300",
  Platinum: "bg-cyan-100 text-cyan-700 border-cyan-300",
  Diamond: "bg-violet-100 text-violet-700 border-violet-300",
};

const RANK_THRESHOLDS = { Bronze: 0, Silver: 50, Gold: 70, Platinum: 85, Diamond: 95 };
const RANK_ORDER = ["Bronze", "Silver", "Gold", "Platinum", "Diamond"];

export default function RankBadge({ rank = "Bronze", size = "sm" }) {
  const style = RANK_STYLES[rank] || RANK_STYLES.Bronze;
  const sizeClass = size === "lg" ? "px-3 py-1 text-sm" : "px-2 py-0.5 text-xs";

  return (
    <span className={`inline-flex items-center rounded-full border font-medium ${style} ${sizeClass}`}>
      {rank}
    </span>
  );
}

export function RankProgress({ rank = "Bronze", score = 50 }) {
  const currentIdx = RANK_ORDER.indexOf(rank);
  const nextRank = RANK_ORDER[currentIdx + 1];
  if (!nextRank) return <p className="text-xs text-arena-muted">Max rank achieved</p>;

  const currentThreshold = RANK_THRESHOLDS[rank];
  const nextThreshold = RANK_THRESHOLDS[nextRank];
  const progress = ((score - currentThreshold) / (nextThreshold - currentThreshold)) * 100;

  return (
    <div className="w-full">
      <div className="flex justify-between text-xs text-arena-muted mb-1">
        <span>{rank}</span>
        <span>{nextRank} ({nextThreshold})</span>
      </div>
      <div className="h-2 bg-arena-border rounded-full overflow-hidden">
        <div
          className="h-full bg-arena-accent rounded-full transition-all"
          style={{ width: `${Math.min(100, Math.max(0, progress))}%` }}
        />
      </div>
    </div>
  );
}
</file>

<file path="app/components/RegisterModal.js">
"use client";

import { useState } from "react";
import { useSession } from "@/lib/SessionContext";
import { createBrowserClient } from "@/lib/supabase";

function GoogleIcon() {
  return (
    <svg width="18" height="18" viewBox="0 0 18 18" xmlns="http://www.w3.org/2000/svg">
      <path d="M17.64 9.2c0-.637-.057-1.251-.164-1.84H9v3.481h4.844a4.14 4.14 0 0 1-1.796 2.716v2.259h2.908c1.702-1.567 2.684-3.875 2.684-6.615z" fill="#4285F4"/>
      <path d="M9 18c2.43 0 4.467-.806 5.956-2.18l-2.908-2.259c-.806.54-1.837.86-3.048.86-2.344 0-4.328-1.584-5.036-3.711H.957v2.332A8.997 8.997 0 0 0 9 18z" fill="#34A853"/>
      <path d="M3.964 10.71A5.41 5.41 0 0 1 3.682 9c0-.593.102-1.17.282-1.71V4.958H.957A8.996 8.996 0 0 0 0 9c0 1.452.348 2.827.957 4.042l3.007-2.332z" fill="#FBBC05"/>
      <path d="M9 3.58c1.321 0 2.508.454 3.44 1.345l2.582-2.58C13.463.891 11.426 0 9 0A8.997 8.997 0 0 0 .957 4.958L3.964 7.29C4.672 5.163 6.656 3.58 9 3.58z" fill="#EA4335"/>
    </svg>
  );
}

export default function RegisterModal({ open, onClose }) {
  const { register, session } = useSession();
  const [username, setUsername] = useState("");
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [confirmPassword, setConfirmPassword] = useState("");
  const [error, setError] = useState(null);
  const [loading, setLoading] = useState(false);

  if (!open) return null;

  const debatesUsed = session?.debate_count || 0;

  const handleGoogle = async () => {
    setError(null);
    const supabase = createBrowserClient();
    const { error: oauthError } = await supabase.auth.signInWithOAuth({
      provider: "google",
      options: { redirectTo: window.location.origin + "/auth/callback" },
    });
    if (oauthError) setError(oauthError.message);
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError(null);

    if (password.length < 8) {
      setError("Password must be at least 8 characters.");
      return;
    }
    if (password !== confirmPassword) {
      setError("Passwords do not match.");
      return;
    }

    setLoading(true);
    try {
      const result = await register(username, email, password);
      if (result.error) {
        setError(result.error);
      } else {
        onClose();
      }
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm">
      <div className="bg-arena-surface border border-arena-border rounded-xl p-6 w-full max-w-md mx-4">
        <h2 className="text-xl font-bold mb-2">Create Your Account</h2>
        <p className="text-sm text-arena-muted mb-4">
          {debatesUsed >= 5
            ? "You've used all 5 guest debates. Register to keep debating!"
            : `${5 - debatesUsed} guest debates remaining. Register for unlimited access.`}
        </p>

        <div className="space-y-4">
          <button
            onClick={handleGoogle}
            className="w-full flex items-center justify-center gap-3 px-4 py-2 border border-arena-border rounded-lg text-sm hover:bg-arena-border/30 transition-colors"
          >
            <GoogleIcon /> Continue with Google
          </button>

          <div className="flex items-center gap-3 text-arena-muted text-xs">
            <hr className="flex-1 border-arena-border" />
            or register with email
            <hr className="flex-1 border-arena-border" />
          </div>

          <form onSubmit={handleSubmit} className="space-y-4">
            <div>
              <label className="block text-sm font-medium mb-1">Username</label>
              <input
                type="text"
                value={username}
                onChange={(e) => setUsername(e.target.value)}
                required
                minLength={3}
                maxLength={24}
                className="w-full bg-arena-bg border border-arena-border rounded-lg px-3 py-2 text-sm focus:outline-none focus:border-arena-accent"
                placeholder="Pick a username"
              />
            </div>

            <div>
              <label className="block text-sm font-medium mb-1">Email</label>
              <input
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                required
                className="w-full bg-arena-bg border border-arena-border rounded-lg px-3 py-2 text-sm focus:outline-none focus:border-arena-accent"
                placeholder="you@example.com"
              />
            </div>

            <div>
              <label className="block text-sm font-medium mb-1">Password</label>
              <input
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                required
                minLength={8}
                className="w-full bg-arena-bg border border-arena-border rounded-lg px-3 py-2 text-sm focus:outline-none focus:border-arena-accent"
                placeholder="At least 8 characters"
              />
            </div>

            <div>
              <label className="block text-sm font-medium mb-1">Confirm Password</label>
              <input
                type="password"
                value={confirmPassword}
                onChange={(e) => setConfirmPassword(e.target.value)}
                required
                className="w-full bg-arena-bg border border-arena-border rounded-lg px-3 py-2 text-sm focus:outline-none focus:border-arena-accent"
                placeholder="Repeat your password"
              />
            </div>

            {error && <p className="text-sm text-arena-con">{error}</p>}

            <div className="flex gap-3">
              <button
                type="button"
                onClick={onClose}
                className="flex-1 px-4 py-2 border border-arena-border rounded-lg text-sm hover:bg-arena-border/30 transition-colors"
              >
                Cancel
              </button>
              <button
                type="submit"
                disabled={loading}
                className="flex-1 px-4 py-2 bg-arena-accent text-white rounded-lg text-sm font-medium hover:bg-arena-accent/80 transition-colors disabled:opacity-50"
              >
                {loading ? "Creating..." : "Register"}
              </button>
            </div>
          </form>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/profile/[id]/ProfileClient.js">
"use client";

import { useState, useEffect } from "react";
import { getProfile } from "@/lib/api-client";
import { useSession } from "@/lib/SessionContext";
import RankBadge, { RankProgress } from "../../components/RankBadge";
import DebateCard from "../../components/DebateCard";

export default function ProfileClient({ initialProfile, profileId }) {
  const { user } = useSession();
  // Start with server-provided data (no loading flash); fetch full data for recent debates
  const [profile, setProfile] = useState(initialProfile || null);
  const [recentDebates, setRecentDebates] = useState([]);
  const [loading, setLoading] = useState(!initialProfile);

  const isOwnProfile = user?.id === profileId;

  useEffect(() => {
    // Always fetch full profile to get recent_debates and latest stats
    getProfile(profileId).then((data) => {
      setProfile(data.user || data);
      setRecentDebates(data.recent_debates || []);
      setLoading(false);
    });
  }, [profileId]);

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-[60vh]">
        <div className="w-10 h-10 border-4 border-arena-accent border-t-transparent rounded-full animate-spin" />
      </div>
    );
  }

  if (!profile) {
    return (
      <div className="text-center py-20">
        <p className="text-arena-muted">Profile not found.</p>
      </div>
    );
  }

  const totalDebates = profile.total_debates || 0;
  const wins = profile.wins || 0;
  const losses = profile.losses || 0;
  const draws = profile.draws || 0;
  const qualityScore = parseFloat(profile.quality_score || profile.quality_score_avg) || 50;

  return (
    <div className="max-w-3xl mx-auto px-4 py-8">
      {/* Header */}
      <div className="bg-arena-surface border border-arena-border rounded-xl p-6 mb-6">
        <div className="flex items-center gap-4 mb-4">
          <div className="w-16 h-16 bg-arena-accent/20 rounded-full flex items-center justify-center">
            <span className="text-2xl font-bold text-arena-accent">
              {(profile.username || "?")[0].toUpperCase()}
            </span>
          </div>
          <div>
            <h1 className="text-2xl font-bold">{profile.username}</h1>
            <div className="flex items-center gap-2 mt-1">
              <RankBadge rank={profile.rank_tier} size="lg" />
              {isOwnProfile && <span className="text-xs text-arena-muted">(You)</span>}
            </div>
          </div>
        </div>

        <RankProgress rank={profile.rank_tier} score={qualityScore} />
      </div>

      {/* Stats grid */}
      <div className="grid grid-cols-2 sm:grid-cols-4 gap-4 mb-6">
        {[
          { label: "Total Debates", value: totalDebates },
          { label: "Wins", value: wins, cls: "text-arena-pro" },
          { label: "Losses", value: losses, cls: "text-arena-con" },
          { label: "Draws", value: draws },
        ].map((stat) => (
          <div key={stat.label} className="bg-arena-surface border border-arena-border rounded-lg p-4 text-center">
            <p className={`text-2xl font-bold ${stat.cls || ""}`}>{stat.value}</p>
            <p className="text-xs text-arena-muted">{stat.label}</p>
          </div>
        ))}
      </div>

      {/* Quality Score */}
      <div className="bg-arena-surface border border-arena-border rounded-xl p-6 mb-6">
        <div className="flex items-center justify-between mb-2">
          <span className="font-semibold">Quality Score</span>
          <span className="text-2xl font-bold text-arena-accent">{qualityScore.toFixed(1)}</span>
        </div>
        <div className="h-3 bg-arena-border rounded-full overflow-hidden">
          <div
            className="h-full bg-arena-accent rounded-full transition-all"
            style={{ width: `${qualityScore}%` }}
          />
        </div>
      </div>

      {/* Recent debates */}
      {recentDebates.length > 0 && (
        <div>
          <h2 className="text-lg font-semibold mb-4">Recent Debates</h2>
          <div className="space-y-3">
            {recentDebates.map((debate) => (
              <DebateCard key={debate.id} debate={debate} />
            ))}
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="lib/queries/getProfileSSR.js">
// Direct Supabase service-role query — no HTTP round-trip, no auth middleware
// Used exclusively in server components and API routes (never in client components)
import { createServiceClient } from "@/lib/supabase";

export async function getProfileSSR(userId) {
  const supabase = createServiceClient();
  const { data } = await supabase
    .from("users")
    .select(
      "id, username, quality_score_avg, rank_tier, total_debates, wins, losses, draws"
    )
    .eq("id", userId)
    .single();
  return data; // null if not found
}
</file>

<file path="lib/pipeline.js">
// ============================================================
// Post-Debate Pipeline
// ============================================================
// Triggered when a debate ends. Orchestrates:
// 1. Stop recording → get download link
// 2. Transcribe with Deepgram
// 3. Run two-tiered AI scoring
// 4. Write results to DB
// 5. Update user stats
// 6. Notify participants
//
// Each step is tracked independently. Failures in one step
// don't block independent downstream steps. The pipeline
// state is persisted so failed steps can be retried.
// ============================================================

import { createServiceClient } from "./supabase.js";
import { stopRecording, getRecordingLink, deleteDailyRoom } from "./daily.js";
import { transcribeAudio, labelTranscriptSpeakers } from "./deepgram.js";
import { runFullAnalysis } from "./scoring.js";

/**
 * Pipeline step status values.
 */
const STEP = {
  PENDING: "pending",
  RUNNING: "running",
  COMPLETED: "completed",
  FAILED: "failed",
  SKIPPED: "skipped",
};

/**
 * Initialize default pipeline state for all steps.
 */
function defaultPipelineState() {
  return {
    recording: { status: STEP.PENDING, error: null, attempts: 0 },
    transcription: { status: STEP.PENDING, error: null, attempts: 0 },
    scoring: { status: STEP.PENDING, error: null, attempts: 0 },
    strikes: { status: STEP.PENDING, error: null, attempts: 0 },
    user_stats: { status: STEP.PENDING, error: null, attempts: 0 },
    notifications: { status: STEP.PENDING, error: null, attempts: 0 },
    cleanup: { status: STEP.PENDING, error: null, attempts: 0 },
    started_at: new Date().toISOString(),
    completed_at: null,
  };
}

/**
 * Persist pipeline state to the debates table.
 */
async function savePipelineState(db, debateId, pipelineState) {
  await db
    .from("debates")
    .update({ pipeline_state: pipelineState })
    .eq("id", debateId);
}

/**
 * Run a single pipeline step with error isolation.
 * Tracks attempts, captures errors, and persists state.
 */
async function runStep(db, debateId, pipelineState, stepName, fn) {
  const step = pipelineState[stepName];
  if (step.status === STEP.COMPLETED) return true;

  step.status = STEP.RUNNING;
  step.attempts += 1;
  await savePipelineState(db, debateId, pipelineState);

  try {
    await fn();
    step.status = STEP.COMPLETED;
    step.error = null;
    await savePipelineState(db, debateId, pipelineState);
    return true;
  } catch (err) {
    step.status = STEP.FAILED;
    step.error = err.message || String(err);
    await savePipelineState(db, debateId, pipelineState);
    console.error(`Pipeline step '${stepName}' failed for debate ${debateId}:`, err);
    return false;
  }
}

/**
 * Full post-debate processing pipeline.
 * Called when debate.status transitions to 'completed'.
 *
 * @param {string} debateId
 * @param {Object} [existingState] - Resume from existing pipeline state
 */
export async function processDebateCompletion(debateId, existingState) {
  const db = createServiceClient();

  // 1. Get debate record
  const { data: debate, error } = await db
    .from("debates")
    .select("*, topics(*)")
    .eq("id", debateId)
    .single();

  if (error || !debate) {
    console.error(`Pipeline: debate ${debateId} not found`, error);
    return { success: false, error: "Debate not found" };
  }

  console.log(`Pipeline: processing debate ${debateId}`);

  // Initialize or resume pipeline state
  const pipelineState = existingState || debate.pipeline_state || defaultPipelineState();
  await savePipelineState(db, debateId, pipelineState);

  // Shared mutable context for passing data between steps
  let audioUrl = debate.audio_url_combined || null;
  let labeledTranscript = debate.transcript?.full_text || null;

  // ── Step 1: Stop recording and get download link ──
  if (debate.daily_room_name) {
    await runStep(db, debateId, pipelineState, "recording", async () => {
      const recording = await stopRecording(debate.daily_room_name);
      if (!recording?.id) {
        // No recording ID — mark as skipped rather than failed
        pipelineState.recording.status = STEP.SKIPPED;
        return;
      }

      await db
        .from("debates")
        .update({
          recording_id: recording.id,
          transcript_status: "processing",
        })
        .eq("id", debateId);

      // Poll for recording (30 attempts × 10s = 5 min max)
      audioUrl = await pollForRecording(recording.id, 30, 10000);

      if (audioUrl) {
        await db
          .from("debates")
          .update({ audio_url_combined: audioUrl })
          .eq("id", debateId);
      } else {
        throw new Error("Recording not available after polling timeout");
      }
    });
  } else {
    pipelineState.recording.status = STEP.SKIPPED;
    await savePipelineState(db, debateId, pipelineState);
  }

  // ── Step 2: Transcribe ──
  if (audioUrl) {
    await runStep(db, debateId, pipelineState, "transcription", async () => {
      const rawTranscript = await transcribeAudio(audioUrl);
      const labeled = labelTranscriptSpeakers(rawTranscript.segments);

      const transcript = {
        segments: labeled.labeled_segments,
        full_text: labeled.full_labeled_text,
        pro_text: labeled.pro_text,
        con_text: labeled.con_text,
        duration: rawTranscript.duration,
      };

      labeledTranscript = labeled.full_labeled_text;

      await db
        .from("debates")
        .update({
          transcript,
          transcript_status: "completed",
        })
        .eq("id", debateId);
    });

    if (pipelineState.transcription.status === STEP.FAILED) {
      await db
        .from("debates")
        .update({ transcript_status: "failed" })
        .eq("id", debateId);
    }
  } else if (pipelineState.recording.status !== STEP.COMPLETED) {
    pipelineState.transcription.status = STEP.SKIPPED;
    await savePipelineState(db, debateId, pipelineState);
  }

  // ── Step 3: AI Scoring (runs even without perfect transcript) ──
  const topicTitle = debate.topics?.title || "Unknown topic";
  const transcriptText = labeledTranscript || "[Transcript unavailable]";
  let analysis = null;

  await runStep(db, debateId, pipelineState, "scoring", async () => {
    await db
      .from("debates")
      .update({ scoring_status: "processing" })
      .eq("id", debateId);

    analysis = await runFullAnalysis(topicTitle, transcriptText, debate.time_limit);

    const proScore = analysis.qualitative?.pro_player?.overall_quality || 50;
    const conScore = analysis.qualitative?.con_player?.overall_quality || 50;

    await db
      .from("debates")
      .update({
        ai_procedural_analysis: analysis.procedural,
        ai_qualitative_analysis: analysis.qualitative,
        pro_quality_score: proScore,
        con_quality_score: conScore,
        scoring_status: "completed",
      })
      .eq("id", debateId);
  });

  if (pipelineState.scoring.status === STEP.FAILED) {
    await db
      .from("debates")
      .update({ scoring_status: "failed" })
      .eq("id", debateId);
  }

  // ── Step 4: Process strikes (independent of stats/notifications) ──
  if (analysis?.procedural) {
    await runStep(db, debateId, pipelineState, "strikes", async () => {
      await processStrikes(db, debate, analysis.procedural);
    });
  } else {
    pipelineState.strikes.status = STEP.SKIPPED;
    await savePipelineState(db, debateId, pipelineState);
  }

  // ── Step 5: Update user stats ──
  if (analysis?.qualitative) {
    const proScore = analysis.qualitative?.pro_player?.overall_quality || 50;
    const conScore = analysis.qualitative?.con_player?.overall_quality || 50;

    await runStep(db, debateId, pipelineState, "user_stats", async () => {
      await updateUserStats(db, debate, proScore, conScore);
    });
  } else {
    pipelineState.user_stats.status = STEP.SKIPPED;
    await savePipelineState(db, debateId, pipelineState);
  }

  // ── Step 6: Notify participants ──
  if (analysis) {
    await runStep(db, debateId, pipelineState, "notifications", async () => {
      await notifyParticipants(db, debate, analysis);
    });
  } else {
    pipelineState.notifications.status = STEP.SKIPPED;
    await savePipelineState(db, debateId, pipelineState);
  }

  // ── Step 7: Clean up Daily.co room ──
  if (debate.daily_room_name) {
    await runStep(db, debateId, pipelineState, "cleanup", async () => {
      await deleteDailyRoom(debate.daily_room_name);
    });
  } else {
    pipelineState.cleanup.status = STEP.SKIPPED;
    await savePipelineState(db, debateId, pipelineState);
  }

  // ── Finalize ──
  pipelineState.completed_at = new Date().toISOString();
  await savePipelineState(db, debateId, pipelineState);

  const failedSteps = Object.entries(pipelineState)
    .filter(([k, v]) => typeof v === "object" && v?.status === STEP.FAILED)
    .map(([k]) => k);

  if (failedSteps.length > 0) {
    console.warn(`Pipeline: debate ${debateId} completed with failures: ${failedSteps.join(", ")}`);
  } else {
    console.log(`Pipeline: debate ${debateId} processing complete`);
  }

  return {
    success: failedSteps.length === 0,
    failedSteps,
    pipelineState,
  };
}

/**
 * Retry failed pipeline steps for a debate.
 * Resumes from persisted pipeline state, only re-running failed steps.
 *
 * @param {string} debateId
 * @returns {Promise<Object>} Pipeline result
 */
export async function retryFailedSteps(debateId) {
  const db = createServiceClient();

  const { data: debate } = await db
    .from("debates")
    .select("pipeline_state")
    .eq("id", debateId)
    .single();

  if (!debate?.pipeline_state) {
    return { success: false, error: "No pipeline state found — run full pipeline first" };
  }

  const state = debate.pipeline_state;

  // Reset failed steps to pending so they re-run
  for (const [key, val] of Object.entries(state)) {
    if (typeof val === "object" && val?.status === STEP.FAILED) {
      val.status = STEP.PENDING;
      val.error = null;
    }
  }
  state.completed_at = null;

  return processDebateCompletion(debateId, state);
}

/**
 * Poll Daily.co for recording download link.
 */
async function pollForRecording(recordingId, maxAttempts, intervalMs) {
  for (let i = 0; i < maxAttempts; i++) {
    try {
      const result = await getRecordingLink(recordingId);
      if (result?.download_link) {
        return result.download_link;
      }
    } catch (_) {
      // Recording not ready yet
    }
    await new Promise((r) => setTimeout(r, intervalMs));
  }
  console.warn(`Recording ${recordingId} not available after ${maxAttempts} attempts`);
  return null;
}

/**
 * Process Tier 1 strike flags — creates strike records for admin review.
 */
async function processStrikes(db, debate, procedural) {
  if (!procedural) return;

  const sides = [
    { key: "pro_strikes", userId: debate.pro_user_id, sessionId: debate.pro_session_id },
    { key: "con_strikes", userId: debate.con_user_id, sessionId: debate.con_session_id },
  ];

  for (const side of sides) {
    const strikes = procedural[side.key];
    if (!strikes) continue;

    for (const [reason, flagged] of Object.entries(strikes)) {
      if (!flagged) continue;

      // Find the corresponding flagged moment for confidence
      const moment = procedural.flagged_moments?.find(
        (m) => m.type === reason && m.speaker === (side.key === "pro_strikes" ? "Pro" : "Con")
      );

      await db.from("strikes").insert({
        user_id: side.userId || null,
        session_id: side.sessionId || null,
        debate_id: debate.id,
        reason,
        ai_confidence: moment?.confidence || 0.9,
        transcript_excerpt: moment?.transcript_excerpt || null,
        admin_reviewed: false,
        admin_decision: "pending",
      });
    }
  }
}

/**
 * Update user quality scores and W/L records.
 * Quality score uses recency-weighted rolling average.
 */
async function updateUserStats(db, debate, proScore, conScore) {
  const updates = [
    { userId: debate.pro_user_id, score: proScore },
    { userId: debate.con_user_id, score: conScore },
  ];

  for (const { userId, score } of updates) {
    if (!userId) continue;

    const { data: user } = await db
      .from("users")
      .select("quality_score_avg, total_debates")
      .eq("id", userId)
      .single();

    if (!user) continue;

    // Recency-weighted average: 80% old score, 20% new score
    const newAvg =
      user.total_debates === 0
        ? score
        : Math.round(user.quality_score_avg * 0.8 + score * 0.2);

    await db
      .from("users")
      .update({
        quality_score_avg: Math.max(0, Math.min(100, newAvg)),
        total_debates: user.total_debates + 1,
      })
      .eq("id", userId);
  }

  // Update topic debate count
  if (debate.topic_id) {
    await db.rpc("increment_topic_debate_count", { topic_uuid: debate.topic_id }).catch(() => {
      // Fallback: manual increment
      db.from("topics")
        .select("debate_count")
        .eq("id", debate.topic_id)
        .single()
        .then(({ data }) => {
          if (data) {
            db.from("topics")
              .update({ debate_count: (data.debate_count || 0) + 1 })
              .eq("id", debate.topic_id);
          }
        });
    });
  }
}

/**
 * Send in-app notifications to debate participants.
 */
async function notifyParticipants(db, debate, analysis) {
  const participants = [
    { userId: debate.pro_user_id, side: "pro" },
    { userId: debate.con_user_id, side: "con" },
  ];

  for (const { userId, side } of participants) {
    if (!userId) continue;

    const playerScores = analysis.qualitative?.[`${side}_player`];
    const overallScore = playerScores?.overall_quality || "N/A";

    await db.from("notifications").insert({
      user_id: userId,
      type: "debate_scored",
      title: "Your debate has been scored!",
      body: `Overall quality: ${overallScore}/100. View the full breakdown.`,
      data: {
        debate_id: debate.id,
        overall_score: overallScore,
      },
    });
  }
}

/**
 * Handle debate forfeit.
 */
export async function processDebateForfeit(debateId, forfeitingSide) {
  const db = createServiceClient();

  const { data: debate } = await db
    .from("debates")
    .select("*")
    .eq("id", debateId)
    .single();

  if (!debate) return;

  const winner = forfeitingSide === "pro" ? "con" : "pro";
  const winnerId = winner === "pro" ? debate.pro_user_id : debate.con_user_id;
  const loserId = forfeitingSide === "pro" ? debate.pro_user_id : debate.con_user_id;

  // Update debate
  await db
    .from("debates")
    .update({
      status: "forfeited",
      phase: "ended",
      winner,
      winner_source: "forfeit",
      completed_at: new Date().toISOString(),
    })
    .eq("id", debateId);

  // Update W/L records
  if (winnerId) {
    await db.rpc("increment_wins", { user_uuid: winnerId }).catch(async () => {
      const { data } = await db.from("users").select("wins, total_debates").eq("id", winnerId).single();
      if (data) await db.from("users").update({ wins: data.wins + 1, total_debates: data.total_debates + 1 }).eq("id", winnerId);
    });
  }
  if (loserId) {
    await db.rpc("increment_losses", { user_uuid: loserId }).catch(async () => {
      const { data } = await db.from("users").select("losses, total_debates").eq("id", loserId).single();
      if (data) await db.from("users").update({ losses: data.losses + 1, total_debates: data.total_debates + 1 }).eq("id", loserId);
    });
  }

  // Cleanup room
  if (debate.daily_room_name) {
    try {
      await stopRecording(debate.daily_room_name);
      await deleteDailyRoom(debate.daily_room_name);
    } catch (_) {}
  }
}
</file>

<file path="supabase/schema.sql">
-- ============================================================
-- DEBATE PLATFORM — Database Schema
-- ============================================================
-- Run this in your Supabase SQL Editor (supabase.com/dashboard → SQL Editor)
-- This creates all tables, indexes, RLS policies, and seed data.
-- ============================================================

-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- ============================================================
-- 1. SESSIONS (unregistered users)
-- ============================================================
CREATE TABLE sessions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  token_hash TEXT UNIQUE NOT NULL,
  fingerprint TEXT, -- SHA-256 of UA + Accept-Language + IP; prevents session farming
  debate_count INTEGER DEFAULT 0,
  strike_count INTEGER DEFAULT 0,
  first_seen TIMESTAMPTZ DEFAULT NOW(),
  last_seen TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_sessions_token ON sessions(token_hash);
CREATE INDEX idx_sessions_fingerprint ON sessions(fingerprint) WHERE fingerprint IS NOT NULL;

-- ============================================================
-- 2. USERS (registered)
-- ============================================================
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  auth_id UUID UNIQUE, -- links to supabase auth.users
  username TEXT UNIQUE NOT NULL,
  email TEXT,
  session_id UUID REFERENCES sessions(id), -- migrated from unregistered
  total_debates INTEGER DEFAULT 0,
  wins INTEGER DEFAULT 0,
  losses INTEGER DEFAULT 0,
  draws INTEGER DEFAULT 0,
  quality_score_avg NUMERIC(5,2) DEFAULT 50.00,
  strike_count INTEGER DEFAULT 0,
  rank_tier TEXT DEFAULT 'Bronze',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  last_active TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_auth_id ON users(auth_id);
CREATE INDEX idx_users_quality_score ON users(quality_score_avg DESC);

-- ============================================================
-- 3. TOPICS
-- ============================================================
CREATE TABLE topics (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  title TEXT NOT NULL,
  short_title TEXT,
  description TEXT,
  category TEXT NOT NULL, -- politics, economics, philosophy, science, culture, silly, fantasy
  is_official BOOLEAN DEFAULT TRUE,
  is_async_only BOOLEAN DEFAULT FALSE,
  creator_id UUID REFERENCES users(id),
  debate_count INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_topics_category ON topics(category);

-- ============================================================
-- 4. MATCHMAKING QUEUE
-- ============================================================
CREATE TABLE matchmaking_queue (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES users(id),
  session_id UUID REFERENCES sessions(id),
  -- one of user_id or session_id must be set
  category TEXT NOT NULL, -- 'quick' or a topic category
  topic_id UUID REFERENCES topics(id), -- null for quick match
  time_limit INTEGER NOT NULL, -- minutes: 5, 15, 45
  stance TEXT NOT NULL DEFAULT 'either', -- pro, con, either
  ranked BOOLEAN DEFAULT FALSE,
  status TEXT DEFAULT 'waiting', -- waiting, matched, expired
  matched_with UUID REFERENCES matchmaking_queue(id),
  debate_id UUID, -- set when debate is created
  created_at TIMESTAMPTZ DEFAULT NOW(),
  expires_at TIMESTAMPTZ DEFAULT NOW() + INTERVAL '10 minutes',
  CONSTRAINT chk_user_or_session CHECK (user_id IS NOT NULL OR session_id IS NOT NULL)
);

CREATE INDEX idx_queue_status ON matchmaking_queue(status, category, time_limit);
CREATE INDEX idx_queue_waiting ON matchmaking_queue(status) WHERE status = 'waiting';

-- ============================================================
-- 5. DEBATES
-- ============================================================
CREATE TABLE debates (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  topic_id UUID REFERENCES topics(id),
  pro_user_id UUID REFERENCES users(id),
  pro_session_id UUID REFERENCES sessions(id),
  con_user_id UUID REFERENCES users(id),
  con_session_id UUID REFERENCES sessions(id),
  time_limit INTEGER NOT NULL, -- minutes
  debate_type TEXT DEFAULT 'live', -- live, async
  ranked BOOLEAN DEFAULT FALSE,

  -- Daily.co room
  daily_room_name TEXT,
  daily_room_url TEXT,

  -- Audio recordings (Daily.co recording URLs or storage paths)
  recording_id TEXT,
  audio_url_pro TEXT,
  audio_url_con TEXT,
  audio_url_combined TEXT,

  -- Transcription
  transcript JSONB, -- { segments: [{ speaker, start, end, text }] }
  transcript_status TEXT DEFAULT 'pending', -- pending, processing, completed, failed

  -- AI Scoring
  ai_procedural_analysis JSONB, -- Tier 1: strike detection
  ai_qualitative_analysis JSONB, -- Tier 2: quality scores
  scoring_status TEXT DEFAULT 'pending', -- pending, processing, completed

  -- Pipeline state (step-level tracking for retry)
  pipeline_state JSONB, -- { recording: {status, error, attempts}, transcription: {...}, ... }

  -- Results
  pro_quality_score NUMERIC(5,2),
  con_quality_score NUMERIC(5,2),
  winner TEXT, -- pro, con, draw, null (pending)
  winner_source TEXT, -- ai, community, forfeit

  -- Status
  status TEXT DEFAULT 'prematch', -- prematch, in_progress, completed, forfeited, cancelled
  phase TEXT DEFAULT 'prematch', -- prematch, opening_pro, opening_con, freeflow, closing_con, closing_pro, ended
  started_at TIMESTAMPTZ,
  completed_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_debates_status ON debates(status);
CREATE INDEX idx_debates_topic ON debates(topic_id);
CREATE INDEX idx_debates_pro_user ON debates(pro_user_id);
CREATE INDEX idx_debates_con_user ON debates(con_user_id);

-- ============================================================
-- 6. ASYNC TURNS
-- ============================================================
CREATE TABLE async_turns (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  debate_id UUID REFERENCES debates(id) ON DELETE CASCADE,
  speaker_side TEXT NOT NULL, -- pro, con
  audio_url TEXT,
  transcript_text TEXT,
  turn_number INTEGER NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  response_deadline TIMESTAMPTZ DEFAULT NOW() + INTERVAL '24 hours'
);

CREATE INDEX idx_async_turns_debate ON async_turns(debate_id, turn_number);

-- ============================================================
-- 7. VOTES
-- ============================================================
CREATE TABLE votes (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  debate_id UUID REFERENCES debates(id) ON DELETE CASCADE,
  voter_id UUID REFERENCES users(id),
  winner_choice TEXT NOT NULL, -- pro, con, draw
  better_arguments TEXT, -- pro, con, equal (optional)
  more_respectful TEXT, -- pro, con, equal (optional)
  changed_mind BOOLEAN, -- optional
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(debate_id, voter_id)
);

CREATE INDEX idx_votes_debate ON votes(debate_id);

-- ============================================================
-- 8. CHALLENGES
-- ============================================================
CREATE TABLE challenges (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  challenger_id UUID REFERENCES users(id),
  target_id UUID REFERENCES users(id),
  topic_id UUID REFERENCES topics(id),
  time_limit INTEGER DEFAULT 15,
  status TEXT DEFAULT 'pending', -- pending, accepted, declined, expired
  created_at TIMESTAMPTZ DEFAULT NOW(),
  expires_at TIMESTAMPTZ DEFAULT NOW() + INTERVAL '7 days'
);

CREATE INDEX idx_challenges_target ON challenges(target_id, status);

-- ============================================================
-- 9. STRIKES
-- ============================================================
CREATE TABLE strikes (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES users(id),
  session_id UUID REFERENCES sessions(id),
  debate_id UUID REFERENCES debates(id),
  reason TEXT NOT NULL, -- ad_hominem, slurs, profanity, non_participation, false_report
  ai_confidence NUMERIC(4,3),
  transcript_excerpt TEXT,
  admin_reviewed BOOLEAN DEFAULT FALSE,
  admin_decision TEXT DEFAULT 'pending', -- pending, confirmed, dismissed
  appealed BOOLEAN DEFAULT FALSE,
  appeal_status TEXT, -- pending, upheld, overturned
  appeal_reason TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  CONSTRAINT chk_strike_user CHECK (user_id IS NOT NULL OR session_id IS NOT NULL)
);

CREATE INDEX idx_strikes_user ON strikes(user_id);
CREATE INDEX idx_strikes_pending ON strikes(admin_reviewed) WHERE admin_reviewed = FALSE;

-- ============================================================
-- 10. NOTIFICATIONS (in-app)
-- ============================================================
CREATE TABLE notifications (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES users(id),
  type TEXT NOT NULL, -- match_found, debate_scored, challenge_received, strike_issued
  title TEXT NOT NULL,
  body TEXT,
  data JSONB, -- arbitrary payload (debate_id, etc.)
  read BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_notifications_user ON notifications(user_id, read, created_at DESC);

-- ============================================================
-- 11. ROW LEVEL SECURITY
-- ============================================================

-- Enable RLS on all tables
ALTER TABLE sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE topics ENABLE ROW LEVEL SECURITY;
ALTER TABLE matchmaking_queue ENABLE ROW LEVEL SECURITY;
ALTER TABLE debates ENABLE ROW LEVEL SECURITY;
ALTER TABLE async_turns ENABLE ROW LEVEL SECURITY;
ALTER TABLE votes ENABLE ROW LEVEL SECURITY;
ALTER TABLE challenges ENABLE ROW LEVEL SECURITY;
ALTER TABLE strikes ENABLE ROW LEVEL SECURITY;
ALTER TABLE notifications ENABLE ROW LEVEL SECURITY;

-- Topics: public read
CREATE POLICY "Topics are publicly readable"
  ON topics FOR SELECT USING (true);

-- Debates: public read for completed, participants for in-progress
CREATE POLICY "Completed debates are publicly readable"
  ON debates FOR SELECT USING (
    status = 'completed'
    OR pro_user_id = auth.uid()
    OR con_user_id = auth.uid()
  );

-- Votes: authenticated users can read all, insert own
CREATE POLICY "Votes are readable by all authenticated users"
  ON votes FOR SELECT USING (auth.role() = 'authenticated');

CREATE POLICY "Users can cast their own votes"
  ON votes FOR INSERT WITH CHECK (voter_id = auth.uid());

-- Notifications: users see their own
CREATE POLICY "Users see their own notifications"
  ON notifications FOR SELECT USING (user_id = auth.uid());

CREATE POLICY "Users can mark own notifications read"
  ON notifications FOR UPDATE USING (user_id = auth.uid());

-- Users: public read for profiles
CREATE POLICY "User profiles are publicly readable"
  ON users FOR SELECT USING (true);

-- Users can update their own record
CREATE POLICY "Users can update own profile"
  ON users FOR UPDATE USING (auth_id = auth.uid());

-- Service role bypasses RLS for all server-side operations
-- (API routes use SUPABASE_SERVICE_ROLE_KEY)

-- ============================================================
-- 12. REALTIME SUBSCRIPTIONS
-- ============================================================
-- Enable realtime for matchmaking and notifications
ALTER PUBLICATION supabase_realtime ADD TABLE matchmaking_queue;
ALTER PUBLICATION supabase_realtime ADD TABLE notifications;
ALTER PUBLICATION supabase_realtime ADD TABLE debates;

-- ============================================================
-- 13. SEED DATA — Official Topics
-- ============================================================

-- Politics
INSERT INTO topics (title, short_title, category, description) VALUES
  ('Universal Basic Income is necessary for the modern economy', 'UBI', 'politics', 'Should governments provide unconditional cash payments to all citizens?'),
  ('Immigration restrictions do more harm than good', 'Immigration', 'politics', 'Are strict immigration policies net negative for society?'),
  ('The Electoral College should be abolished', 'Electoral College', 'politics', 'Should the US move to a popular vote system for presidential elections?'),
  ('Gun ownership is a fundamental right that should not be restricted', 'Gun Control', 'politics', 'Does the Second Amendment protect an individual right to bear arms without restriction?');

-- Economics
INSERT INTO topics (title, short_title, category, description) VALUES
  ('Cryptocurrency regulation will stifle innovation', 'Crypto Regulation', 'economics', 'Would government oversight of crypto markets do more harm than good?'),
  ('Rent control is an effective solution to housing affordability', 'Rent Control', 'economics', 'Do price controls on housing actually help renters long-term?'),
  ('Free trade agreements benefit all participating nations', 'Free Trade', 'economics', 'Are multilateral trade deals win-win or do they create losers?'),
  ('A 4-day work week would boost productivity', '4-Day Work Week', 'economics', 'Can we work less and produce more?');

-- Philosophy
INSERT INTO topics (title, short_title, category, description) VALUES
  ('Free will is an illusion', 'Free Will', 'philosophy', 'Are our choices determined by prior causes, or do we have genuine agency?'),
  ('Utilitarianism is the most ethical framework', 'Utilitarianism', 'philosophy', 'Should we always act to maximize overall happiness?'),
  ('AI systems can be genuinely conscious', 'AI Consciousness', 'philosophy', 'Is subjective experience possible in artificial systems?'),
  ('Moral relativism is intellectually bankrupt', 'Moral Relativism', 'philosophy', 'Are there universal moral truths, or is ethics culturally determined?');

-- Science
INSERT INTO topics (title, short_title, category, description) VALUES
  ('Nuclear energy is essential for combating climate change', 'Nuclear Energy', 'science', 'Is nuclear power a necessary part of the clean energy transition?'),
  ('GMOs are safe and necessary for food security', 'GMOs', 'science', 'Should we embrace genetic modification of crops?'),
  ('Mars colonization should be humanity''s top priority', 'Mars Colony', 'science', 'Should we invest trillions in becoming a multi-planetary species?'),
  ('Human gene editing should be permitted for enhancement', 'Gene Editing', 'science', 'Should CRISPR be used beyond treating disease?');

-- Culture
INSERT INTO topics (title, short_title, category, description) VALUES
  ('Social media has been a net negative for society', 'Social Media', 'culture', 'Has the rise of social platforms done more harm than good?'),
  ('Cancel culture is a healthy form of accountability', 'Cancel Culture', 'culture', 'Is public shaming an effective tool for social justice?'),
  ('Meritocracy is a myth', 'Meritocracy', 'culture', 'Does success truly reflect talent and effort, or structural advantages?'),
  ('Remote work is better than office work', 'Remote Work', 'culture', 'Should remote-first be the default for knowledge workers?');

-- Silly
INSERT INTO topics (title, short_title, category, description) VALUES
  ('A hot dog is a sandwich', 'Hot Dog Sandwich', 'silly', 'Bread on two sides, filling in the middle. Case closed?'),
  ('Cereal is soup', 'Cereal Is Soup', 'silly', 'Liquid + solid ingredients in a bowl. Soup.'),
  ('Pineapple belongs on pizza', 'Pineapple Pizza', 'silly', 'The great Hawaiian pizza debate.'),
  ('Water is wet', 'Water Is Wet', 'silly', 'Is water itself wet, or does it only make other things wet?'),
  ('A taco is a sandwich', 'Taco Sandwich', 'silly', 'Where does the sandwich end and the taco begin?');

-- Fantasy / Fandom
INSERT INTO topics (title, short_title, category, description) VALUES
  ('Thanos was morally justified', 'Thanos Did Nothing Wrong', 'fantasy', 'Was the snap a utilitarian necessity?'),
  ('The Jedi Order is an authoritarian cult', 'Jedi Are Authoritarian', 'fantasy', 'Child recruitment, emotional suppression, political manipulation.'),
  ('Aragorn would beat Jon Snow in single combat', 'Aragorn vs Jon Snow', 'fantasy', 'Numenorean king vs bastard of Winterfell.'),
  ('Gandalf should have used the eagles to fly to Mordor', 'Eagle Plot Hole', 'fantasy', 'The biggest plot hole in fantasy, or is there a good explanation?'),
  ('The Empire did more good than harm for the galaxy', 'Empire Apologia', 'fantasy', 'Infrastructure, order, and stability vs authoritarianism.'),
  ('Palpatine''s rise to power was morally defensible', 'Palpatine Morality', 'fantasy', 'Was he a political genius operating within the system?');

-- ============================================================
-- 14. HELPER FUNCTIONS
-- ============================================================

-- Function to calculate rank tier from quality score
CREATE OR REPLACE FUNCTION calculate_rank_tier(score NUMERIC)
RETURNS TEXT AS $$
BEGIN
  IF score >= 95 THEN RETURN 'Diamond';
  ELSIF score >= 85 THEN RETURN 'Platinum';
  ELSIF score >= 70 THEN RETURN 'Gold';
  ELSIF score >= 50 THEN RETURN 'Silver';
  ELSE RETURN 'Bronze';
  END IF;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- Trigger to auto-update rank_tier when quality_score changes
CREATE OR REPLACE FUNCTION update_rank_tier()
RETURNS TRIGGER AS $$
BEGIN
  NEW.rank_tier := calculate_rank_tier(NEW.quality_score_avg);
  NEW.last_active := NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_update_rank_tier
  BEFORE UPDATE ON users
  FOR EACH ROW
  WHEN (OLD.quality_score_avg IS DISTINCT FROM NEW.quality_score_avg)
  EXECUTE FUNCTION update_rank_tier();

-- Function to expire stale queue entries
CREATE OR REPLACE FUNCTION expire_stale_queue()
RETURNS void AS $$
BEGIN
  UPDATE matchmaking_queue
  SET status = 'expired'
  WHERE status = 'waiting' AND expires_at < NOW();
END;
$$ LANGUAGE plpgsql;

-- ============================================================
-- 15. SCHEDULED JOBS (pg_cron — enable in Supabase Dashboard > Extensions)
-- ============================================================
-- Expire stale queue entries every minute.
-- Requires pg_cron extension enabled in Supabase Dashboard.
-- Uncomment after enabling pg_cron:
--
-- SELECT cron.schedule(
--   'expire-stale-queue',
--   '* * * * *',           -- every minute
--   $$SELECT expire_stale_queue()$$
-- );
--
-- Expire old challenges every hour:
-- SELECT cron.schedule(
--   'expire-old-challenges',
--   '0 * * * *',           -- every hour
--   $$UPDATE challenges SET status = 'expired' WHERE status = 'pending' AND expires_at < NOW()$$
-- );
</file>

<file path=".gitignore">
node_modules/
.next/
dist/
.env.local
.env*.local
.vercel
.DS_Store
</file>

<file path="vercel.json">
{
  "installCommand": "npm install"
}
</file>

<file path="app/api/auth/session/route.js">
import { NextResponse } from "next/server";
import { createServiceClient } from "@/lib/supabase";
import { randomBytes, createHash } from "crypto";

/**
 * POST /api/auth/session
 * Create or retrieve a session for an unregistered user.
 * Uses a browser fingerprint (UA + Accept-Language + IP hash) to
 * prevent trivial session farming via localStorage clearing.
 *
 * Body: { token? }
 */
export async function POST(request) {
  try {
    const body = await request.json();
    const { token } = body;
    const db = createServiceClient();
    const fingerprint = buildFingerprint(request);

    if (token) {
      // Retrieve existing session by token
      const tokenHash = hashToken(token);
      const { data: session } = await db
        .from("sessions")
        .select("*")
        .eq("token_hash", tokenHash)
        .single();

      if (session) {
        // Update last_seen (and fingerprint if column exists)
        const updatePayload = { last_seen: new Date().toISOString() };
        if (fingerprint) updatePayload.fingerprint = fingerprint;

        const { error: updateErr } = await db
          .from("sessions")
          .update(updatePayload)
          .eq("id", session.id);

        if (updateErr && fingerprint) {
          // fingerprint column may not exist — retry without it
          await db
            .from("sessions")
            .update({ last_seen: new Date().toISOString() })
            .eq("id", session.id);
        }

        return NextResponse.json({
          session_id: session.id,
          debate_count: session.debate_count,
          strike_count: session.strike_count,
          debates_remaining: Math.max(0, 5 - session.debate_count),
        });
      }
      // Token not found — fall through to fingerprint check / new session
    }

    // Check if a session already exists for this fingerprint.
    // This catches users who clear localStorage to bypass the 5-debate limit.
    // Wrapped in try/catch — if the fingerprint column doesn't exist, skip gracefully.
    if (fingerprint) {
      try {
        const { data: fingerprintSession } = await db
          .from("sessions")
          .select("*")
          .eq("fingerprint", fingerprint)
          .order("last_seen", { ascending: false })
          .limit(1)
          .single();

        if (fingerprintSession) {
          const newToken = randomBytes(32).toString("hex");
          const newTokenHash = hashToken(newToken);

          await db
            .from("sessions")
            .update({
              token_hash: newTokenHash,
              last_seen: new Date().toISOString(),
            })
            .eq("id", fingerprintSession.id);

          return NextResponse.json({
            token: newToken,
            session_id: fingerprintSession.id,
            debate_count: fingerprintSession.debate_count,
            strike_count: fingerprintSession.strike_count,
            debates_remaining: Math.max(0, 5 - fingerprintSession.debate_count),
            reattached: true,
          });
        }
      } catch {
        // fingerprint column likely doesn't exist — skip reattachment
      }
    }

    // No existing session — create new one
    const newToken = randomBytes(32).toString("hex");
    const tokenHash = hashToken(newToken);

    // Try inserting with fingerprint; fall back without it if column is missing
    const insertPayload = { token_hash: tokenHash };
    if (fingerprint) insertPayload.fingerprint = fingerprint;

    let { data: session, error } = await db
      .from("sessions")
      .insert(insertPayload)
      .select()
      .single();

    if (error && fingerprint) {
      // fingerprint column may not exist — retry without it
      ({ data: session, error } = await db
        .from("sessions")
        .insert({ token_hash: tokenHash })
        .select()
        .single());
    }

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    return NextResponse.json({
      token: newToken,
      session_id: session.id,
      debate_count: 0,
      strike_count: 0,
      debates_remaining: 5,
    });
  } catch (err) {
    return NextResponse.json({ error: err.message }, { status: 500 });
  }
}

/**
 * Build a browser fingerprint from request headers.
 * Combines User-Agent, Accept-Language, and client IP into a stable hash.
 * Not perfect (VPN/incognito can bypass) but raises the bar significantly.
 */
function buildFingerprint(request) {
  const ua = request.headers.get("user-agent") || "";
  const lang = request.headers.get("accept-language") || "";
  // x-forwarded-for is set by Vercel/reverse proxies
  const ip = request.headers.get("x-forwarded-for")?.split(",")[0]?.trim()
    || request.headers.get("x-real-ip")
    || "";

  if (!ua && !ip) return null;

  const raw = `${ua}|${lang}|${ip}`;
  return createHash("sha256").update(raw).digest("hex");
}

function hashToken(token) {
  return createHash("sha256").update(token).digest("hex");
}
</file>

<file path="app/components/PhaseTimer.js">
"use client";

import { useState, useEffect, useRef } from "react";

const PHASE_LABELS = {
  opening_pro: "Opening — Pro",
  opening_con: "Opening — Con",
  freeflow: "Free Discussion",
  closing_con: "Closing — Con",
  closing_pro: "Closing — Pro",
  ended: "Debate Ended",
};

// Phase durations in seconds based on debate time limit
const PHASE_DURATIONS = {
  5: { opening: 45, freeflow: 120, closing: 30 },
  15: { opening: 120, freeflow: 480, closing: 90 },
  45: { opening: 300, freeflow: 1500, closing: 300 },
};

export function getPhaseDuration(phase, timeLimit) {
  const durations = PHASE_DURATIONS[timeLimit] || PHASE_DURATIONS[15];
  if (phase.startsWith("opening")) return durations.opening;
  if (phase === "freeflow") return durations.freeflow;
  if (phase.startsWith("closing")) return durations.closing;
  return 0;
}

export default function PhaseTimer({ phase, timeLimit, onTimeUp }) {
  const duration = getPhaseDuration(phase, timeLimit);
  const [remaining, setRemaining] = useState(duration);
  const callbackRef = useRef(onTimeUp);
  callbackRef.current = onTimeUp;

  useEffect(() => {
    setRemaining(duration);
  }, [phase, duration]);

  useEffect(() => {
    if (remaining <= 0 || phase === "ended" || phase === "prematch") return;

    const interval = setInterval(() => {
      setRemaining((r) => {
        if (r <= 1) {
          clearInterval(interval);
          callbackRef.current?.();
          return 0;
        }
        return r - 1;
      });
    }, 1000);

    return () => clearInterval(interval);
  }, [phase, remaining > 0]);

  const mins = Math.floor(remaining / 60);
  const secs = remaining % 60;
  const progress = duration > 0 ? (remaining / duration) * 100 : 0;
  const urgent = remaining < 10 && remaining > 0;

  return (
    <div className="flex flex-col items-center gap-2">
      <p className="text-sm font-medium text-arena-muted">
        {PHASE_LABELS[phase] || phase}
      </p>

      <div className="relative w-28 h-28">
        <svg className="w-full h-full -rotate-90" viewBox="0 0 100 100">
          <circle cx="50" cy="50" r="44" fill="none" stroke="var(--color-arena-border)" strokeWidth="6" />
          <circle
            cx="50" cy="50" r="44" fill="none"
            stroke={urgent ? "var(--color-arena-con)" : "var(--color-arena-accent)"}
            strokeWidth="6"
            strokeLinecap="round"
            strokeDasharray={`${2 * Math.PI * 44}`}
            strokeDashoffset={`${2 * Math.PI * 44 * (1 - progress / 100)}`}
            className="transition-all duration-1000"
          />
        </svg>
        <div className="absolute inset-0 flex items-center justify-center">
          <span className={`text-2xl font-mono font-bold ${urgent ? "text-arena-con animate-pulse" : ""}`}>
            {mins}:{secs.toString().padStart(2, "0")}
          </span>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/components/TopicCard.js">
"use client";

const CATEGORY_COLORS = {
  politics: "bg-blue-100 text-blue-700",
  economics: "bg-emerald-100 text-emerald-700",
  philosophy: "bg-amber-100 text-amber-700",
  science: "bg-cyan-100 text-cyan-700",
  culture: "bg-pink-100 text-pink-700",
  silly: "bg-yellow-100 text-yellow-700",
  fantasy: "bg-violet-100 text-violet-700",
};

export default function TopicCard({ topic, onClick }) {
  const catColor = CATEGORY_COLORS[topic.category] || "bg-arena-border text-arena-muted";

  return (
    <button
      onClick={() => onClick?.(topic)}
      className="w-full text-left bg-arena-card border border-arena-border rounded-xl p-4 hover:border-arena-accent hover:shadow-sm transition-all group"
    >
      <div className="flex items-start justify-between gap-2 mb-2">
        <span className={`text-xs font-medium px-2 py-0.5 rounded-full ${catColor}`}>
          {topic.category}
        </span>
        {topic.debate_count > 0 && (
          <span className="text-xs text-arena-muted">{topic.debate_count} debates</span>
        )}
      </div>
      <h3 className="font-semibold text-sm group-hover:text-arena-accent transition-colors leading-snug">
        {topic.short_title || topic.title}
      </h3>
      {topic.description && (
        <p className="text-xs text-arena-muted mt-1 line-clamp-2">{topic.description}</p>
      )}
    </button>
  );
}
</file>

<file path="app/profile/[id]/page.js">
import { notFound } from "next/navigation";
import { getProfileSSR } from "@/lib/queries/getProfileSSR";
import ProfileClient from "./ProfileClient";

export async function generateMetadata({ params }) {
  const { id: profileId } = params;
  const profile = await getProfileSSR(profileId);

  if (!profile) {
    return { title: "Profile Not Found | Arena.gg" };
  }

  const username = profile.username || "Debater";
  const rankTier = profile.rank_tier || "Bronze";
  const wins = profile.wins || 0;
  const losses = profile.losses || 0;
  const qualityScore = parseFloat(
    profile.quality_score_avg || profile.quality_score || 50
  ).toFixed(1);

  const title = `@${username} | Arena.gg`;
  const description = `${rankTier} · ${wins}W ${losses}L · Quality Score: ${qualityScore}`;
  const ogImageUrl = `/api/og/profile?userId=${profileId}`;

  return {
    title,
    description,
    openGraph: {
      title,
      description,
      images: [{ url: ogImageUrl, width: 1200, height: 630 }],
      type: "profile",
    },
    twitter: {
      card: "summary_large_image",
      title,
      description,
      images: [ogImageUrl],
    },
  };
}

export default async function ProfilePage({ params }) {
  const { id: profileId } = params;
  const profile = await getProfileSSR(profileId);

  if (!profile) {
    notFound();
  }

  return <ProfileClient initialProfile={profile} profileId={profileId} />;
}
</file>

<file path="app/topics/page.js">
import { createServiceClient } from "@/lib/supabase";
import TopicsFilter from "./TopicsFilter";

export const dynamic = 'force-dynamic';

export async function generateMetadata() {
  return {
    title: "Browse Debate Topics | Arena.gg",
    description:
      "Debate politics, philosophy, science, and more. Pick a topic and get matched instantly.",
    openGraph: {
      title: "Browse Debate Topics | Arena.gg",
      description:
        "Debate politics, philosophy, science, and more. Pick a topic and get matched instantly.",
      type: "website",
    },
    twitter: {
      card: "summary",
      title: "Browse Debate Topics | Arena.gg",
      description:
        "Debate politics, philosophy, science, and more. Pick a topic and get matched instantly.",
    },
  };
}

export default async function TopicsPage() {
  const supabase = createServiceClient();
  const { data: topics } = await supabase
    .from("topics")
    .select("*")
    .order("category")
    .order("title");

  return (
    <div className="max-w-6xl mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-6">Topics</h1>
      <TopicsFilter topics={topics || []} />
    </div>
  );
}
</file>

<file path="app/globals.css">
@import "tailwindcss";

@theme {
  --color-arena-bg:       #FAF8F5;
  --color-arena-surface:  #F3EDE6;
  --color-arena-card:     #FFFFFF;
  --color-arena-border:   #E8DDD0;
  --color-arena-text:     #1A1A1A;
  --color-arena-text-dim: #6B7280;
  --color-arena-muted:    #9CA3AF;
  --color-arena-pro:      #22C55E;
  --color-arena-con:      #EF4444;
  --color-arena-accent:   #FF6B35;
}

body {
  background-color: var(--color-arena-bg);
  color: var(--color-arena-text);
  font-family: 'Ruluko', system-ui, -apple-system, sans-serif;
}

/* Scrollbar styling */
::-webkit-scrollbar {
  width: 6px;
}
::-webkit-scrollbar-track {
  background: var(--color-arena-bg);
}
::-webkit-scrollbar-thumb {
  background: var(--color-arena-border);
  border-radius: 3px;
}
</file>

<file path="app/layout.js">
import "./globals.css";
import { Providers } from "./providers";
import Nav from "./components/Nav";

export const metadata = {
  title: "Arena.gg — Debate Anyone",
  description: "Voice-based debates with random opponents. AI-scored. Community-judged.",
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <head>
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossOrigin="anonymous" />
        <link href="https://fonts.googleapis.com/css2?family=Ruluko&display=swap" rel="stylesheet" />
      </head>
      <body className="min-h-screen bg-arena-bg text-arena-text antialiased">
        <Providers>
          <Nav />
          <main className="pt-16">{children}</main>
        </Providers>
      </body>
    </html>
  );
}
</file>

<file path="lib/queries/getDebateSSR.js">
// Direct Supabase service-role query — no HTTP round-trip, no auth middleware
// Used exclusively in server components and API routes (never in client components)
import { createServiceClient } from "@/lib/supabase";

export async function getDebateSSR(debateId) {
  const supabase = createServiceClient();
  const { data, error } = await supabase
    .from("debates")
    .select(`
      *,
      topics(title, short_title, category, description),
      pro_user:users!pro_user_id(username, rank_tier),
      con_user:users!con_user_id(username, rank_tier)
    `)
    .eq("id", debateId)
    .single();

  console.log("getDebateSSR:", debateId, "data:", !!data, "error:", error?.message || null);

  if (!data) return null;

  // Flatten nested user joins into top-level fields
  return {
    ...data,
    pro_username: data.pro_user?.username || null,
    pro_rank_tier: data.pro_user?.rank_tier || null,
    con_username: data.con_user?.username || null,
    con_rank_tier: data.con_user?.rank_tier || null,
  };
}
</file>

<file path="app/page.js">
import Link from "next/link";
import HomeHero from "./HomeHero";

export const metadata = {
  title: "Arena.gg — Debate Anyone",
  description:
    "Voice-based debates with random opponents. AI-scored. Community-judged.",
  openGraph: {
    title: "Arena.gg — Debate Anyone",
    description:
      "Voice-based debates with random opponents. AI-scored. Community-judged.",
    type: "website",
  },
  twitter: {
    card: "summary_large_image",
    title: "Arena.gg — Debate Anyone",
    description:
      "Voice-based debates with random opponents. AI-scored. Community-judged.",
  },
};

export default function Home() {
  return (
    <>
      <div className="max-w-6xl mx-auto px-4">
        {/* Hero */}
        <section className="py-20 sm:py-32 text-center">
          <h1 className="text-4xl sm:text-6xl font-bold mb-4">
            Argue with Strangers.{" "}
            <span className="text-arena-accent">Win nothing.</span>
          </h1>
          <p className="text-lg text-arena-muted max-w-xl mx-auto mb-8">
            Voice-based debates with random opponents. AI-scored. Community-judged.
            Climb the ranks from Bronze to Diamond.
          </p>
          <div className="flex items-center justify-center gap-4">
            <HomeHero />
            <Link
              href="/topics"
              className="px-8 py-3 border border-arena-border rounded-lg font-semibold hover:bg-arena-surface transition-colors text-lg"
            >
              Browse Topics
            </Link>
          </div>
        </section>

        {/* Stats strip */}
        <section className="grid grid-cols-2 sm:grid-cols-4 gap-4 py-8 border-t border-b border-arena-border">
          {[
            { label: "Active Debaters", value: "128" },
            { label: "Debates Today", value: "47" },
            { label: "Topics", value: "30+" },
            { label: "Avg. Quality Score", value: "72.4" },
          ].map((stat) => (
            <div key={stat.label} className="text-center">
              <p className="text-2xl font-bold text-arena-accent">{stat.value}</p>
              <p className="text-sm text-arena-muted">{stat.label}</p>
            </div>
          ))}
        </section>

        {/* How it works */}
        <section className="py-16">
          <h2 className="text-2xl font-bold text-center mb-10">How It Works</h2>
          <div className="grid sm:grid-cols-3 gap-8">
            {[
              {
                step: "1",
                title: "Join a Debate",
                desc: "Pick a topic or get matched randomly. Choose your time limit and stance.",
                icon: (
                  <svg className="w-8 h-8" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={1.5}>
                    <path strokeLinecap="round" strokeLinejoin="round" d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197M13 7a4 4 0 11-8 0 4 4 0 018 0z" />
                  </svg>
                ),
              },
              {
                step: "2",
                title: "Argue Your Case",
                desc: "Opening statements, free discussion, and closing arguments — all via live audio.",
                icon: (
                  <svg className="w-8 h-8" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={1.5}>
                    <path strokeLinecap="round" strokeLinejoin="round" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" />
                  </svg>
                ),
              },
              {
                step: "3",
                title: "Get Scored",
                desc: "AI analyzes coherence, evidence, and engagement. Community votes on the winner.",
                icon: (
                  <svg className="w-8 h-8" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={1.5}>
                    <path strokeLinecap="round" strokeLinejoin="round" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
                  </svg>
                ),
              },
            ].map((item) => (
              <div key={item.step} className="bg-arena-surface border border-arena-border rounded-xl p-6 text-center">
                <div className="w-14 h-14 bg-arena-accent/10 text-arena-accent rounded-full flex items-center justify-center mx-auto mb-4">
                  {item.icon}
                </div>
                <h3 className="font-semibold mb-2">{item.title}</h3>
                <p className="text-sm text-arena-muted">{item.desc}</p>
              </div>
            ))}
          </div>
        </section>
      </div>
    </>
  );
}
</file>

<file path="lib/api-client.js">
// ============================================================
// Client API Layer
// ============================================================
// All fetch calls from the frontend to the API routes.
// The React components import from here — never call fetch directly.
// ============================================================

const API = "";

// ---- SESSION (unregistered users) ----

const SESSION_KEY = "debate_session_token";

export async function getOrCreateSession() {
  const existingToken = localStorage.getItem(SESSION_KEY);

  const res = await fetch(`${API}/api/auth/session`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ token: existingToken || undefined }),
  });

  const data = await res.json();
  if (!res.ok) {
    throw new Error(data.error || `Session API error (${res.status})`);
  }
  if (data.token) {
    localStorage.setItem(SESSION_KEY, data.token);
  }
  return data;
}

// ---- AUTH / REGISTRATION ----

export async function registerUser(username, email, password, sessionId) {
  const res = await fetch(`${API}/api/auth/register`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ username, email, password, sessionId }),
  });
  return res.json();
}

export async function loginWithPassword(email, password) {
  const res = await fetch(`${API}/api/auth/login`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ email, password }),
  });
  return res.json();
}

export async function loginWithOAuth(accessToken) {
  const res = await fetch(`${API}/api/auth/oauth`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ accessToken }),
  });
  return res.json();
}

// ---- MATCHMAKING ----

export async function enterQueue({ userId, sessionId, category, topicId, timeLimit, stance, ranked }) {
  const res = await fetch(`${API}/api/matchmaking/queue`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ userId, sessionId, category, topicId, timeLimit, stance, ranked }),
  });
  return res.json();
}

export async function leaveQueue(queueId) {
  const res = await fetch(`${API}/api/matchmaking/queue`, {
    method: "DELETE",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ queueId }),
  });
  return res.json();
}

// ---- DAILY.CO ROOM ----

export async function getDailyToken(debateId, userId, sessionId, side) {
  const res = await fetch(`${API}/api/daily/room`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ debateId, userId, sessionId, side }),
  });
  return res.json();
}

// ---- DEBATE LIFECYCLE ----

export async function startDebate(debateId) {
  const res = await fetch(`${API}/api/debates/complete`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ debateId, action: "start" }),
  });
  return res.json();
}

export async function advancePhase(debateId, phase) {
  const res = await fetch(`${API}/api/debates/complete`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ debateId, action: "phase", phase }),
  });
  return res.json();
}

export async function completeDebate(debateId) {
  const res = await fetch(`${API}/api/debates/complete`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ debateId, action: "complete" }),
  });
  return res.json();
}

export async function forfeitDebate(debateId, side) {
  const res = await fetch(`${API}/api/debates/complete`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ debateId, action: "forfeit", side }),
  });
  return res.json();
}

// ---- DEBATE DETAIL ----

export async function getDebateDetail(debateId) {
  const res = await fetch(`${API}/api/debates/detail?debateId=${debateId}`);
  return res.json();
}

// ---- SIDE SWAP (prematch) ----

export async function requestSideSwap(debateId, requestingSide) {
  const res = await fetch(`${API}/api/debates/swap`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ debateId, requestingSide }),
  });
  return res.json();
}

// ---- VOTES ----

export async function castVote(debateId, voterId, winnerChoice, extras = {}) {
  const res = await fetch(`${API}/api/votes/cast`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ debateId, voterId, winnerChoice, ...extras }),
  });
  return res.json();
}

export async function getVoteTally(debateId) {
  const res = await fetch(`${API}/api/votes/cast?debateId=${debateId}`);
  return res.json();
}

// ---- PROFILE ----

export async function getProfile(userId) {
  const res = await fetch(`${API}/api/profile/me?userId=${userId}`);
  return res.json();
}

// ---- NOTIFICATIONS ----

export async function getNotifications(userId, { unreadOnly = false, limit = 50 } = {}) {
  const params = new URLSearchParams({ userId });
  if (unreadOnly) params.set("unreadOnly", "true");
  if (limit !== 50) params.set("limit", String(limit));

  const res = await fetch(`${API}/api/notifications?${params}`);
  return res.json();
}

export async function markNotificationsRead(notificationIds) {
  const res = await fetch(`${API}/api/notifications`, {
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ notificationIds }),
  });
  return res.json();
}

export async function markAllNotificationsRead(userId) {
  const res = await fetch(`${API}/api/notifications`, {
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ userId, markAllRead: true }),
  });
  return res.json();
}

// ---- CHALLENGES ----

export async function createChallenge(challengerId, targetId, topicId, timeLimit) {
  const res = await fetch(`${API}/api/challenges`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ challengerId, targetId, topicId, timeLimit }),
  });
  return res.json();
}

export async function respondToChallenge(challengeId, action) {
  const res = await fetch(`${API}/api/challenges`, {
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ challengeId, action }),
  });
  return res.json();
}

export async function getChallenges(userId, type = "received") {
  const res = await fetch(`${API}/api/challenges?userId=${userId}&type=${type}`);
  return res.json();
}

// ---- SCORING (admin) ----

export async function triggerScoring(debateId) {
  const res = await fetch(`${API}/api/scoring/trigger`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ debateId }),
  });
  return res.json();
}

export async function retryScoring(debateId) {
  const res = await fetch(`${API}/api/scoring/trigger`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ debateId, retry: true }),
  });
  return res.json();
}
</file>

<file path="lib/SessionContext.js">
"use client";

import { createContext, useContext, useState, useEffect, useCallback } from "react";
import { getOrCreateSession, registerUser } from "./api-client";

const SessionContext = createContext(null);

export function SessionProvider({ children }) {
  const [state, setState] = useState({
    user: null,
    session: null,
    loading: true,
  });

  useEffect(() => {
    getOrCreateSession()
      .then((data) => {
        setState({
          user: data.user || null,
          session: data.session || data,
          loading: false,
        });
      })
      .catch((err) => {
        console.error("Session init failed:", err);
        setState((s) => ({ ...s, loading: false, sessionError: err.message }));
      });
  }, []);

  const login = useCallback((userData) => {
    setState((s) => ({ ...s, user: userData }));
  }, []);

  const logout = useCallback(() => {
    localStorage.removeItem("debate_session_token");
    setState({ user: null, session: null, loading: false });
    // Re-create anonymous session
    getOrCreateSession().then((data) => {
      setState({ user: null, session: data.session || data, loading: false });
    });
  }, []);

  const register = useCallback(
    async (username, email, password) => {
      const result = await registerUser(username, email, password, state.session?.session_id);
      if (result.user) {
        setState((s) => ({ ...s, user: result.user }));
      }
      return result;
    },
    [state.session]
  );

  return (
    <SessionContext.Provider value={{ ...state, login, logout, register }}>
      {children}
    </SessionContext.Provider>
  );
}

export function useSession() {
  const ctx = useContext(SessionContext);
  if (!ctx) throw new Error("useSession must be used within SessionProvider");
  return ctx;
}
</file>

<file path="package.json">
{
  "name": "debate-platform",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "db:setup": "node supabase/setup.mjs"
  },
  "dependencies": {
    "@anthropic-ai/sdk": "^0.39.0",
    "@daily-co/daily-js": "^0.62.0",
    "@deepgram/sdk": "^3.9.0",
    "@supabase/ssr": "^0.5.2",
    "@supabase/supabase-js": "^2.49.1",
    "@vercel/functions": "^3.4.2",
    "next": "^14.2.21",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "uuid": "^10.0.0"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4.1.18",
    "@types/node": "^22.0.0",
    "@types/react": "^18.3.0",
    "postcss": "^8.5.6",
    "tailwindcss": "^4.1.18"
  }
}
</file>

<file path="lib/matchmaking.js">
// ============================================================
// Matchmaking Engine
// ============================================================
// Handles queue entry, opponent matching, side assignment,
// prematch lobby with side swap, and debate room creation.
//
// Uses Supabase realtime for instant match notifications.
// ============================================================

import { createServiceClient } from "./supabase.js";
import { createDailyRoom, createMeetingToken } from "./daily.js";

/**
 * Add a user to the matchmaking queue.
 * @returns {{ queueEntry, immediateMatch? }}
 */
export async function enterQueue({
  userId,       // null if unregistered
  sessionId,    // null if registered
  category,     // 'quick' or topic category
  topicId,      // null for quick match
  timeLimit,    // 5, 15, or 45
  stance,       // 'pro', 'con', 'either'
  ranked,       // boolean
}) {
  const db = createServiceClient();

  // Check for existing queue entry
  const identityFilter = userId
    ? { column: "user_id", value: userId }
    : { column: "session_id", value: sessionId };

  const { data: existing } = await db
    .from("matchmaking_queue")
    .select("id")
    .eq(identityFilter.column, identityFilter.value)
    .eq("status", "waiting")
    .limit(1);

  if (existing && existing.length > 0) {
    // Already in queue — return existing entry
    return { queueEntry: existing[0], alreadyQueued: true };
  }

  // Insert into queue
  const entry = {
    user_id: userId || null,
    session_id: sessionId || null,
    category,
    topic_id: topicId || null,
    time_limit: timeLimit,
    stance,
    ranked,
    status: "waiting",
  };

  const { data: queueEntry, error } = await db
    .from("matchmaking_queue")
    .insert(entry)
    .select()
    .single();

  if (error) throw new Error(`Queue insert failed: ${error.message}`);

  // Expire stale queue entries before searching for a match
  try {
    await db.rpc("expire_stale_queue");
  } catch {
    // Fallback: inline expiry (RPC may not exist)
    await db
      .from("matchmaking_queue")
      .update({ status: "expired" })
      .eq("status", "waiting")
      .lt("expires_at", new Date().toISOString());
  }

  // Immediately try to find a match
  const match = await findMatch(db, queueEntry);

  return { queueEntry, match };
}

/**
 * Find a matching opponent in the queue.
 */
async function findMatch(db, entry) {
  console.log("FINDMATCH: searching", JSON.stringify({ id: entry.id, category: entry.category, time_limit: entry.time_limit, stance: entry.stance, ranked: entry.ranked, session_id: entry.session_id, user_id: entry.user_id }));
  // Build match query — only match with non-expired waiting entries
  let query = db
    .from("matchmaking_queue")
    .select("*")
    .eq("status", "waiting")
    .eq("time_limit", entry.time_limit)
    .eq("ranked", entry.ranked)
    .neq("id", entry.id)
    .gte("expires_at", new Date().toISOString());

  // Category matching
  if (entry.category === "quick") {
    query = query.eq("category", "quick");
  } else {
    query = query.eq("category", entry.category);
    if (entry.topic_id) {
      // Match on same topic, or anyone with no specific topic
      query = query.or(`topic_id.eq.${entry.topic_id},topic_id.is.null`);
    }
  }

  // Stance matching: prefer opposite stance
  if (entry.stance === "pro") {
    // Look for con or either
    query = query.in("stance", ["con", "either"]);
  } else if (entry.stance === "con") {
    query = query.in("stance", ["pro", "either"]);
  }
  // If stance is 'either', match with anyone

  // Exclude same user
  if (entry.user_id) {
    query = query.or(`user_id.neq.${entry.user_id},user_id.is.null`);
  }
  if (entry.session_id) {
    query = query.or(`session_id.neq.${entry.session_id},session_id.is.null`);
  }

  // FIFO — oldest first
  query = query.order("created_at", { ascending: true }).limit(1);

  const { data: opponents, error } = await query;

  console.log("FINDMATCH: result", JSON.stringify({ count: opponents?.length, error: error?.message, first: opponents?.[0]?.id }));
  if (!opponents || opponents.length === 0) {
    return null; // No match found, stay in queue
  }

  const opponent = opponents[0];

  // Assign sides
  const { proEntry, conEntry } = assignSides(entry, opponent);

  // Select topic for quick match
  let topicId = entry.topic_id || opponent.topic_id;
  if (!topicId) {
    topicId = await getRandomTopic(db, entry.category);
  }

  // Create the debate record
  const { data: debate, error: debateErr } = await db
    .from("debates")
    .insert({
      topic_id: topicId,
      pro_user_id: proEntry.user_id || null,
      pro_session_id: proEntry.session_id || null,
      con_user_id: conEntry.user_id || null,
      con_session_id: conEntry.session_id || null,
      time_limit: entry.time_limit,
      ranked: entry.ranked,
      status: "prematch",
      phase: "prematch",
    })
    .select()
    .single();

  if (debateErr) throw new Error(`Debate creation failed: ${debateErr.message}`);

  // Create Daily.co room
  const room = await createDailyRoom(debate.id, entry.time_limit);

  // Generate meeting tokens for both participants
  const proLabel = proEntry.user_id
    ? await getUsername(db, proEntry.user_id)
    : "Pro";
  const conLabel = conEntry.user_id
    ? await getUsername(db, conEntry.user_id)
    : "Con";

  const proToken = await createMeetingToken(room.name, proLabel, true);
  const conToken = await createMeetingToken(room.name, conLabel, false);

  // Update debate with room info
  await db
    .from("debates")
    .update({
      daily_room_name: room.name,
      daily_room_url: room.url,
    })
    .eq("id", debate.id);

  // Update both queue entries as matched
  await db
    .from("matchmaking_queue")
    .update({
      status: "matched",
      matched_with: opponent.id,
      debate_id: debate.id,
    })
    .eq("id", entry.id);

  await db
    .from("matchmaking_queue")
    .update({
      status: "matched",
      matched_with: entry.id,
      debate_id: debate.id,
    })
    .eq("id", opponent.id);

  // Send in-app notifications
  for (const qe of [proEntry, conEntry]) {
    if (qe.user_id) {
      await db.from("notifications").insert({
        user_id: qe.user_id,
        type: "match_found",
        title: "Match found!",
        body: "Your debate is ready. Join now.",
        data: { debate_id: debate.id },
      });
    }
  }

  return {
    debate_id: debate.id,
    topic_id: topicId,
    room_name: room.name,
    room_url: room.url,
    pro: {
      queue_id: proEntry.id,
      user_id: proEntry.user_id,
      session_id: proEntry.session_id,
      token: proToken,
      label: proLabel,
    },
    con: {
      queue_id: conEntry.id,
      user_id: conEntry.user_id,
      session_id: conEntry.session_id,
      token: conToken,
      label: conLabel,
    },
  };
}

/**
 * Assign Pro/Con sides based on stance preferences.
 */
function assignSides(entryA, entryB) {
  // If one explicitly chose pro
  if (entryA.stance === "pro") return { proEntry: entryA, conEntry: entryB };
  if (entryB.stance === "pro") return { proEntry: entryB, conEntry: entryA };

  // If one explicitly chose con
  if (entryA.stance === "con") return { proEntry: entryB, conEntry: entryA };
  if (entryB.stance === "con") return { proEntry: entryA, conEntry: entryB };

  // Both are 'either' — random assignment
  if (Math.random() > 0.5) {
    return { proEntry: entryA, conEntry: entryB };
  }
  return { proEntry: entryB, conEntry: entryA };
}

/**
 * Get a random topic for quick match.
 */
async function getRandomTopic(db, category) {
  let query = db.from("topics").select("id").eq("is_official", true);

  if (category && category !== "quick") {
    query = query.eq("category", category);
  }

  const { data: topics } = await query;
  if (!topics || topics.length === 0) return null;

  const random = topics[Math.floor(Math.random() * topics.length)];
  return random.id;
}

/**
 * Get username from user_id.
 */
async function getUsername(db, userId) {
  const { data } = await db
    .from("users")
    .select("username")
    .eq("id", userId)
    .single();
  return data?.username || "Anonymous";
}

/**
 * Handle side swap request in prematch lobby.
 * Both players must request a swap for it to happen.
 */
export async function requestSideSwap(debateId, requestingSide) {
  const db = createServiceClient();

  const { data: debate } = await db
    .from("debates")
    .select("*")
    .eq("id", debateId)
    .single();

  if (!debate || debate.phase !== "prematch") {
    return { swapped: false, reason: "Debate not in prematch phase" };
  }

  // Store swap requests in a simple metadata approach
  // We'll use a convention: check if both sides requested
  // For MVP, we track this client-side via Supabase realtime channel
  // and execute the swap server-side when both confirm

  // Swap the user/session IDs
  const { error } = await db
    .from("debates")
    .update({
      pro_user_id: debate.con_user_id,
      pro_session_id: debate.con_session_id,
      con_user_id: debate.pro_user_id,
      con_session_id: debate.pro_session_id,
    })
    .eq("id", debateId)
    .eq("phase", "prematch");

  if (error) return { swapped: false, reason: error.message };
  return { swapped: true };
}

/**
 * Leave the matchmaking queue.
 */
export async function leaveQueue(queueId) {
  const db = createServiceClient();
  await db
    .from("matchmaking_queue")
    .update({ status: "expired" })
    .eq("id", queueId)
    .eq("status", "waiting");
}
</file>

<file path="app/components/MatchmakingModal.js">
"use client";

import { useState, useEffect, useCallback } from "react";
import { useRouter } from "next/navigation";
import { useSession } from "@/lib/SessionContext";
import { enterQueue, leaveQueue } from "@/lib/api-client";
import { useRealtimeMatch, useMatchPolling } from "@/lib/useRealtime";

export default function MatchmakingModal({ open, onClose, topic = null }) {
  const router = useRouter();
  const { user, session, loading: sessionLoading } = useSession();
  const [timeLimit, setTimeLimit] = useState(15);
  const [stance, setStance] = useState("either");
  const [ranked, setRanked] = useState(false);
  const [searching, setSearching] = useState(false);
  const [queueId, setQueueId] = useState(null);
  const [elapsed, setElapsed] = useState(0);
  const [error, setError] = useState(null);

  const isGuest = !user;

  const onMatch = useCallback(
    (match) => {
      setSearching(false);
      setQueueId(null);
      onClose();
      router.push(`/debate/${match.debateId}`);
    },
    [router, onClose]
  );

  useRealtimeMatch(queueId, onMatch);
  useMatchPolling(queueId, onMatch);

  // Elapsed timer
  useEffect(() => {
    if (!searching) return;
    const interval = setInterval(() => setElapsed((e) => e + 1), 1000);
    return () => clearInterval(interval);
  }, [searching]);

  const handleSearch = async () => {
    setError(null);
    if (sessionLoading) {
      setError("Loading session… please wait a moment.");
      return;
    }
    if (!user?.id && !session?.session_id) {
      setError("Session not ready — please refresh the page.");
      return;
    }
    setSearching(true);
    setElapsed(0);
    try {
      const result = await enterQueue({
        userId: user?.id,
        sessionId: session?.session_id,
        category: topic?.category || "quick",
        topicId: topic?.id || null,
        timeLimit,
        stance,
        ranked: ranked && !isGuest,
      });
      console.log("QUEUE RESPONSE:", JSON.stringify(result));
      if (result.error) {
        setError(result.error);
        setSearching(false);
        return;
      }
      // If match was already found synchronously (second user into queue)
      if (result.match?.debate_id) {
        setSearching(false);
        onClose();
        router.push(`/debate/${result.match.debate_id}`);
        return;
      }
      // Otherwise wait for realtime/polling to fire
      setQueueId(result.queueEntry?.id);
    } catch (err) {
      setError(err.message);
      setSearching(false);
    }
  };

  const handleCancel = async () => {
    if (queueId) {
      await leaveQueue(queueId);
    }
    setSearching(false);
    setQueueId(null);
    setElapsed(0);
  };

  if (!open) return null;

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm">
      <div className="bg-arena-surface border border-arena-border rounded-xl p-6 w-full max-w-md mx-4">
        {searching ? (
          <div className="text-center py-8">
            <div className="w-16 h-16 border-4 border-arena-accent border-t-transparent rounded-full animate-spin mx-auto mb-4" />
            <h3 className="text-lg font-bold mb-1">Finding Opponent...</h3>
            <p className="text-arena-muted text-sm mb-4">
              {Math.floor(elapsed / 60)}:{(elapsed % 60).toString().padStart(2, "0")} elapsed
            </p>
            <button
              onClick={handleCancel}
              className="px-6 py-2 border border-arena-border rounded-lg text-sm hover:bg-arena-border/30 transition-colors"
            >
              Cancel
            </button>
          </div>
        ) : (
          <>
            <h2 className="text-xl font-bold mb-1">
              {topic ? "Start Debate" : "Quick Match"}
            </h2>
            {topic && (
              <p className="text-sm text-arena-muted mb-4">{topic.short_title || topic.title}</p>
            )}
            {!topic && (
              <p className="text-sm text-arena-muted mb-4">Random topic, random opponent</p>
            )}

            <div className="space-y-4">
              {/* Time limit */}
              <div>
                <label className="block text-sm font-medium mb-2">Time Limit</label>
                <div className="flex gap-2">
                  {[5, 15, 45].map((t) => (
                    <button
                      key={t}
                      onClick={() => setTimeLimit(t)}
                      className={`flex-1 py-2 rounded-lg text-sm font-medium transition-colors ${
                        timeLimit === t
                          ? "bg-arena-accent text-white"
                          : "bg-arena-bg border border-arena-border hover:border-arena-accent"
                      }`}
                    >
                      {t} min
                    </button>
                  ))}
                </div>
              </div>

              {/* Stance */}
              <div>
                <label className="block text-sm font-medium mb-2">Stance</label>
                <div className="flex gap-2">
                  {[
                    { val: "pro", label: "Pro", cls: "bg-arena-pro/20 border-arena-pro text-arena-pro" },
                    { val: "con", label: "Con", cls: "bg-arena-con/20 border-arena-con text-arena-con" },
                    { val: "either", label: "Either", cls: "bg-arena-accent/20 border-arena-accent text-arena-accent" },
                  ].map(({ val, label, cls }) => (
                    <button
                      key={val}
                      onClick={() => setStance(val)}
                      className={`flex-1 py-2 rounded-lg text-sm font-medium border transition-colors ${
                        stance === val ? cls : "bg-arena-bg border-arena-border hover:border-arena-accent"
                      }`}
                    >
                      {label}
                    </button>
                  ))}
                </div>
              </div>

              {/* Ranked toggle */}
              <div className="flex items-center justify-between">
                <div>
                  <span className="text-sm font-medium">Ranked</span>
                  {isGuest && (
                    <span className="text-xs text-arena-muted ml-2">(Register to unlock)</span>
                  )}
                </div>
                <button
                  onClick={() => !isGuest && setRanked(!ranked)}
                  disabled={isGuest}
                  className={`w-10 h-6 rounded-full transition-colors relative ${
                    ranked && !isGuest ? "bg-arena-accent" : "bg-arena-border"
                  } ${isGuest ? "opacity-40 cursor-not-allowed" : "cursor-pointer"}`}
                >
                  <span
                    className={`absolute top-0.5 w-5 h-5 bg-white rounded-full transition-transform ${
                      ranked && !isGuest ? "translate-x-4.5" : "translate-x-0.5"
                    }`}
                  />
                </button>
              </div>

              {error && <p className="text-sm text-arena-con">{error}</p>}

              <div className="flex gap-3 pt-2">
                <button
                  onClick={onClose}
                  className="flex-1 px-4 py-2.5 border border-arena-border rounded-lg text-sm hover:bg-arena-border/30 transition-colors"
                >
                  Cancel
                </button>
                <button
                  onClick={handleSearch}
                  disabled={sessionLoading}
                  className="flex-1 px-4 py-2.5 bg-arena-accent text-white rounded-lg text-sm font-medium hover:bg-arena-accent/80 transition-colors disabled:opacity-50"
                >
                  {sessionLoading ? "Loading..." : "Find Match"}
                </button>
              </div>
            </div>
          </>
        )}
      </div>
    </div>
  );
}
</file>

<file path="app/debate/[id]/page.js">
import { notFound } from "next/navigation";
import { getDebateSSR } from "@/lib/queries/getDebateSSR";
import DebateClient from "./DebateClient";

export const dynamic = "force-dynamic";

export async function generateMetadata({ params }) {
  const { id: debateId } = params;
  const debate = await getDebateSSR(debateId);

  if (!debate) {
    return { title: "Debate Not Found | Arena.gg" };
  }

  const topicTitle =
    debate.topics?.title || debate.topic_title || "Quick Match";
  const proName = debate.pro_username || "Pro";
  const conName = debate.con_username || "Con";

  let title, description;

  if (debate.status === "completed" || debate.status === "forfeited") {
    const winner = debate.winner;
    const winnerName =
      winner === "pro" ? proName : winner === "con" ? conName : null;
    title = `${proName} vs ${conName} — ${topicTitle} | Arena.gg`;
    description =
      winner === "draw"
        ? `Draw! Quality scores: ${debate.pro_quality_score ?? "?"} vs ${debate.con_quality_score ?? "?"}`
        : winnerName
        ? `Winner: ${winnerName} · Quality scores: ${debate.pro_quality_score ?? "?"} vs ${debate.con_quality_score ?? "?"}`
        : `Debate completed · ${topicTitle}`;
  } else {
    title = `${topicTitle} — Live Debate | Arena.gg`;
    description = `${proName} vs ${conName} are debating right now`;
  }

  const ogImageUrl = `/api/og?debateId=${debateId}`;

  return {
    title,
    description,
    openGraph: {
      title,
      description,
      images: [{ url: ogImageUrl, width: 1200, height: 630 }],
      type: "website",
    },
    twitter: {
      card: "summary_large_image",
      title,
      description,
      images: [ogImageUrl],
    },
  };
}

export default async function DebatePage({ params }) {
  const { id: debateId } = params;

  let debate;
  try {
    debate = await getDebateSSR(debateId);
  } catch (err) {
    console.error("DEBATE PAGE: getDebateSSR threw", debateId, err?.message);
    throw err; // re-throw so Next.js shows a 500 instead of silently 404ing
  }

  console.log("DEBATE PAGE: debateId =", debateId, "found =", !!debate);

  if (!debate) {
    notFound();
  }

  // Flatten nested joins so DebateClient receives the same shape
  // as it gets from getDebateDetail() at runtime
  const flatDebate = {
    ...debate,
    topic_title: debate.topics?.title || debate.topic_title,
    topic_description: debate.topics?.description || debate.topic_description,
    pro_username: debate.pro_username || debate.pro_user?.username || null,
    pro_rank_tier: debate.pro_rank_tier || debate.pro_user?.rank_tier || null,
    con_username: debate.con_username || debate.con_user?.username || null,
    con_rank_tier: debate.con_rank_tier || debate.con_user?.rank_tier || null,
  };

  return <DebateClient initialDebate={flatDebate} params={params} />;
}
</file>

</files>
